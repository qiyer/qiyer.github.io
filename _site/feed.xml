<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Qiye Blog</title>
    <description>关于前端与设计、黑客与画家 | 黄玄，Web &amp; Mobile Lover，Front-End Engineer，UX Designer | 这里是 @Hux黄玄 的个人博客，与你一起发现更大的世界。</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 28 Feb 2017 17:24:13 +0800</pubDate>
    <lastBuildDate>Tue, 28 Feb 2017 17:24:13 +0800</lastBuildDate>
    <generator>Jekyll v3.3.1</generator>
    
      <item>
        <title>下一代 Web 应用模型 —— Progressive Web App</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;本文首发于&lt;a href=&quot;http://geek.csdn.net/news/detail/135595&quot;&gt;《程序员》&lt;/a&gt;，发布于 &lt;a href=&quot;https://huangxuan.me&quot;&gt;Hux Blog&lt;/a&gt;、&lt;a href=&quot;https://zhuanlan.zhihu.com/FrontendMagazine&quot;&gt;前端外刊评论&lt;/a&gt;，转载请保留链接 ;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;下一代-web-应用&quot;&gt;下一代 Web 应用？&lt;/h2&gt;

&lt;p&gt;近年来，Web 应用在整个软件与互联网行业承载的责任越来越重，软件复杂度和维护成本越来越高，Web 技术，尤其是 Web 客户端技术，迎来了爆发式的发展。&lt;/p&gt;

&lt;p&gt;包括但不限于基于 Node.js 的前端工程化方案；诸如 Webpack、Rollup 这样的打包工具；Babel、PostCSS 这样的转译工具；TypeScript、Elm 这样转译至 JavaScript 的编程语言；React、Angular、Vue 这样面向现代 web 应用需求的前端框架及其生态，也涌现出了像&lt;a href=&quot;http://nerds.airbnb.com/isomorphic-javascript-future-web-apps/&quot; title=&quot;Isomorphic JavaScript: The Future of Web Apps&quot;&gt;同构 JavaScript&lt;/a&gt;与&lt;a href=&quot;https://medium.com/@mjackson/universal-javascript-4761051b7ae9#.unrzyz3b2&quot; title=&quot;Universal JavaScript&quot;&gt;通用 JavaScript 应用&lt;/a&gt;这样将服务器端渲染（Server-side Rendering）与单页面应用模型（Single-page App）结合的 web 应用架构方式，可以说是百花齐放。&lt;/p&gt;

&lt;p&gt;但是，Web 应用在移动时代并没有达到其在桌面设备上流行的程度。究其原因，尽管上述的各种方案已经充分利用了现有的 JavaScript 计算能力、CSS 布局能力、HTTP 缓存与浏览器 API 对当代基于 &lt;a href=&quot;https://en.wikipedia.org/wiki/Ajax_(programming)&quot; title=&quot;Ajax - Wikipedia&quot;&gt;Ajax&lt;/a&gt; 与&lt;a href=&quot;https://en.wikipedia.org/wiki/Responsive_web_design&quot; title=&quot;Responsive Web Design - Wikipedia&quot;&gt;响应式设计&lt;/a&gt;的 web 应用模型的性能与体验带来了工程角度的巨大突破，我们仍然无法在不借助原生程序辅助浏览器的前提下突破 web 平台本身对 web 应用固有的桎梏：&lt;strong&gt;客户端软件（即网页）需要下载所带来的网络延迟；与 Web 应用依赖浏览器作为入口所带来的体验问题。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-nextgen-web-pwa/PWAR-007.jpeg&quot; alt=&quot;&quot; /&gt;
&lt;em&gt;Web 与原生应用在移动平台上的使用时长对比 &lt;a href=&quot;https://developers.google.com/web/events/pwaroadshow/&quot;&gt;图片来源: Google&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;在桌面设备上，由于网络条件稳定，屏幕尺寸充分，交互方式趋向于多任务，这两点造成的负面影响对比 web 应用免于安装、随叫随到、无需更新等优点，瑕不掩瑜。但是在移动时代，脆弱的网络连接与全新的人机交互方式使得这两个问题被无限放大，严重制约了 web 应用在移动平台的发展。在用户眼里，原生应用不会出现「白屏」，清一色都摆在主屏幕上；而 web 应用则是浏览器这个应用中的应用，使用起来并不方便，而且加载也比原生应用要慢。&lt;/p&gt;

&lt;p&gt;Progressive Web Apps（以下简称 PWA）以及构成 PWA 的一系列关键技术的出现，终于让我们看到了彻底解决这两个平台级别问题的曙光：能够显著提高应用加载速度、甚至让 web 应用可以在离线环境使用的 Service Worker 与 Cache Storage；用于描述 web 应用元数据（metadata）、让 web 应用能够像原生应用一样被添加到主屏、全屏执行的 Web App Manifest；以及进一步提高 web 应用与操作系统集成能力，让 web 应用能在未被激活时发起推送通知的 Push API 与 Notification API 等等。&lt;/p&gt;

&lt;p&gt;将这些技术组合在一起会是怎样的效果呢？「印度阿里巴巴」 —— &lt;a href=&quot;https://en.wikipedia.org/wiki/Flipkart&quot; title=&quot;Flipkart - wikipedia&quot;&gt;Flipkart&lt;/a&gt; 在 2015 年一度关闭了自己的移动端网站，却在年底发布了现在最为人津津乐道的 PWA 案例 &lt;em&gt;FlipKart Lite&lt;/em&gt;，成为世界上第一个支撑大规模业务的 PWA。发布的一周后它就亮相于 &lt;a href=&quot;https://youtu.be/m2a9hlUFRhg&quot; title=&quot;Keynote (Chrome Dev Summit 2015)&quot;&gt;Chrome Dev Summit 2015&lt;/a&gt; 上，笔者当时就被惊艳到了。为了方便各媒介上的读者观看，笔者做了几幅图方便给大家介绍：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-nextgen-web-pwa/flipkart-1.jpeg&quot; alt=&quot;&quot; /&gt;
&lt;em&gt;图片来源: Hux &amp;amp; &lt;a href=&quot;https://medium.com/@AdityaPunjani/building-flipkart-lite-a-progressive-web-app-2c211e641883#.hz4d3kw41&quot; title=&quot;Building Flipkart Lite: A Progressive Web App&quot;&gt;Medium.com&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;当浏览器发现用户&lt;a href=&quot;https://developers.google.com/web/fundamentals/engage-and-retain/app-install-banners/?hl=en&quot; title=&quot;Web App Install Banners - Google Developer&quot;&gt;需要&lt;/a&gt; Flipkart Lite 时，它就会提示用户「嘿，你可以把它添加至主屏哦」（用户也可以手动添加）。这样，Flipkart Lite 就会像原生应用一样在主屏上留下一个自定义的 icon 作为入口；与一般的书签不同，当用户点击 icon 时，Flipkat Lite 将直接全屏打开，不再受困于浏览器的 UI 中，而且有自己的启动屏效果。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-nextgen-web-pwa/flipkart-2.jpeg&quot; alt=&quot;&quot; /&gt;
&lt;em&gt;图片来源: Hux &amp;amp; &lt;a href=&quot;https://medium.com/@AdityaPunjani/building-flipkart-lite-a-progressive-web-app-2c211e641883#.hz4d3kw41&quot; title=&quot;Building Flipkart Lite: A Progressive Web App&quot;&gt;Medium.com&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;更强大的是，在无法访问网络时，Flipkart Lite 可以像原生应用一样照常执行，还会很骚气的变成黑白色；不但如此，曾经访问过的商品都会被缓存下来得以在离线时继续访问。在商品降价、促销等时刻，Flipkart Lite 会像原生应用一样发起推送通知，吸引用户回到应用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;无需担心网络延迟；有着独立入口与独立的保活机制。&lt;/strong&gt;之前两个问题的一并解决，宣告着 web 应用在移动设备上的浴火重生：满足 PWA 模型的 web 应用，将逐渐成为移动操作系统的一等公民，并将向原生应用发起挑战与「复仇」。&lt;/p&gt;

&lt;p&gt;更令笔者兴奋的是，就在今年 11 月的 &lt;a href=&quot;https://youtu.be/eI3B6x0fw9s&quot; title=&quot;Keynote (Chrome Dev Summit 2016)&quot;&gt;Chrome Dev Summit 2016&lt;/a&gt; 上，Chrome 的工程 VP Darin Fisher 介绍了 Chrome 团队正在做的一些实验：把「添加至主屏」重命名为「安装」，被安装的 PWA 不再仅以 widget 的形式显示在桌面上，而是真正做到与所有原生应用平级，一样被收纳进应用抽屉（App Drawer）里，一样出现在系统设置中 🎉🎉🎉。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-nextgen-web-pwa/flipkart-3.jpeg&quot; alt=&quot;&quot; /&gt;
&lt;em&gt;图片来源: Hux &amp;amp; &lt;a href=&quot;https://twitter.com/adityapunjani&quot;&gt;@adityapunjani&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;图中从左到右分别为：类似原生应用的安装界面；被收纳在应用抽屉里的 Flipkart Lite 与 Hux Blog；设置界面中并列出现的 Flipkart 原生应用与 Flipkart Lite PWA （可以看到 PWA 巨大的体积优势）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;笔者相信，PWA 模型将继约 20 年前横空出世的 Ajax 与约 10 年前风靡移动互联网的响应式设计之后，掀起 web 应用模型的第三次根本性革命，将 web 应用带进一个全新的时代。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;pwa-关键技术的前世今生&quot;&gt;PWA 关键技术的前世今生&lt;/h2&gt;

&lt;h3 id=&quot;web-app-manifest&quot;&gt;&lt;a href=&quot;https://w3c.github.io/manifest/#use-cases-and-requirements&quot; title=&quot;Web App Manifest&quot;&gt;Web App Manifest&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Web App Manifest，即通过一个清单文件向浏览器暴露 web 应用的元数据，包括名字、icon 的 URL 等，以备浏览器使用，比如在添加至主屏或推送通知时暴露给操作系统，从而增强 web 应用与操作系统的集成能力。&lt;/p&gt;

&lt;p&gt;让 web 应用在移动设备上的体验更接近原生应用的尝试其实早在 2008 年的 &lt;a href=&quot;https://huangxuan.me/pwa-qcon2016/#/37&quot; title=&quot;PWA@QCon2016 #37&quot;&gt;iOS 1.1.3 与 iOS 2.1.0 &lt;/a&gt;时就开始了，它们分别为 web 应用增加了对自定义 icon 和全屏打开的支持。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-nextgen-web-pwa/ios2-a2hs.gif&quot; alt=&quot;&quot; /&gt;
&lt;em&gt;图片来源: &lt;a href=&quot;http://appleinsider.com/articles/08/10/03/latest_iphone_software_supports_full_screen_web_apps.html&quot;&gt;appleinsider.com&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;但是很快，随着越来越多的私有平台通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;link&amp;gt;&lt;/code&gt; 标签来为 web 应用添加「私货」，&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 很快就被塞满了：&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;&amp;lt;!-- Add to homescreen for Safari on iOS --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;apple-mobile-web-app-capable&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;yes&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;apple-mobile-web-app-status-bar-style&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;black&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;apple-mobile-web-app-title&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Lighten&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;&amp;lt;!-- Add to homescreen for Chrome on Android --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;mobile-web-app-capable&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;yes&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;mate&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;theme-color&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;#000000&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;&amp;lt;!-- Icons for iOS and Android Chrome M31~M38 --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;link&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;rel=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;apple-touch-icon-precomposed&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;sizes=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;144x144&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;images/touch/apple-touch-icon-144x144-precomposed.png&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;link&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;rel=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;apple-touch-icon-precomposed&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;sizes=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;114x114&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;images/touch/apple-touch-icon-114x114-precomposed.png&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;link&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;rel=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;apple-touch-icon-precomposed&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;sizes=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;72x72&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;images/touch/apple-touch-icon-72x72-precomposed.png&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;link&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;rel=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;apple-touch-icon-precomposed&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;images/touch/apple-touch-icon-57x57-precomposed.png&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;&amp;lt;!-- Icon for Android Chrome, recommended --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;link&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;rel=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;shortcut icon&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;sizes=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;196x196&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;images/touch/touch-icon-196x196.png&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;&amp;lt;!-- Tile icon for Win8 (144x144 + tile color) --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;msapplication-TileImage&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;images/touch/ms-touch-icon-144x144-precomposed.png&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;msapplication-TileColor&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;#3372DF&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;&amp;lt;!-- Generic Icon --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;link&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;rel=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;shortcut icon&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;images/touch/touch-icon-57x57.png&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;显然，这种做法并不优雅：分散又重复的元数据定义多余且难以维持同步，与 html 耦合在一起也加重了浏览器检查元数据未来变动的成本。与此同时，社区里开始出现使用 manifest 文件以中心化地描述元数据的方案，比如 &lt;a href=&quot;https://developer.chrome.com/extensions/manifest&quot; title=&quot;Chrome Apps Manifest&quot;&gt;Chrome Extension、 Chrome Hosted Web Apps (2010)&lt;/a&gt; 与 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Archive/Firefox_OS/Firefox_OS_apps/Building_apps_for_Firefox_OS/Manifest&quot; title=&quot;Firefox OS App Manifest&quot;&gt;Firefox OS App Manifest (2011)&lt;/a&gt; 使用 JSON；&lt;a href=&quot;http://cordova.apache.org/docs/en/6.x/config_ref/index.html&quot; title=&quot;Config.xml - Apache Cordova&quot;&gt;Cordova&lt;/a&gt; 与 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/dn320426%28v=vs.85%29.aspx&quot; title=&quot;Browser configuration schema reference - MSDN&quot;&gt;Windows Pinned Site&lt;/a&gt; 使用 XML；&lt;/p&gt;

&lt;p&gt;2013 年，W3C WebApps 工作组开始对基于 JSON 的 Manifest 进行标准化，于同年年底发布&lt;a href=&quot;https://www.w3.org/TR/2013/WD-appmanifest-20131217/&quot; title=&quot;Manifest for web apps and bookmarks - First Public Working Draft&quot;&gt;第一份公开 Working Draft&lt;/a&gt;，并逐渐演化成为今天的 W3C Web App Manifest：&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;short_name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Manifest Sample&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Web Application Manifest Sample&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;icons&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;src&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;launcher-icon-2x.png&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;sizes&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;96x96&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;type&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;image/png&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
   &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}],&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;scope&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;/sample/&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;start_url&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;/sample/index.html&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;display&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;standalone&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;orientation&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;landscape&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;theme_color&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;#000&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;background_color&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;#fff&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;&amp;lt;!-- document --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;link&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;rel=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;manifest&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/manifest.json&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;诸如 &lt;code class=&quot;highlighter-rouge&quot;&gt;name&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;icons&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;display&lt;/code&gt; 都是我们比较熟悉的，而大部分新增的成员则为 web 应用带来了一系列以前 web 应用想做却做不到（或在之前只能靠 hack）的新特性：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;scope&lt;/code&gt;：定义了 web 应用的浏览作用域，比如作用域外的 URL 就会打开浏览器而不会在当前 PWA 里继续浏览。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;start_url&lt;/code&gt;：定义了一个 PWA 的入口页面。比如说你添加 &lt;a href=&quot;https://huangxuan.me&quot; title=&quot;Hux Blog&quot;&gt;Hux Blog&lt;/a&gt; 的任何一个文章到主屏，从主屏打开时都会访问 &lt;a href=&quot;https://huangxuan.me&quot; title=&quot;Hux Blog&quot;&gt;Hux Blog&lt;/a&gt; 的主页。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;orientation&lt;/code&gt;：终于，我们可以锁定屏幕旋转了（喜极而泣…）&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;theme_color&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;background_color&lt;/code&gt;：主题色与背景色，用于配置一些可定制的操作系统 UI 以提高用户体验，比如 Android 的状态栏、任务栏等。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个清单的成员还有很多，比如用于声明「对应原生应用」的 &lt;code class=&quot;highlighter-rouge&quot;&gt;related_applications&lt;/code&gt; 等等，本文就不一一列举了。作为 PWA 的「户口本」，承载着 web 应用与操作系统集成能力的重任，Web App Manifest 还将在日后不断扩展，以满足 web 应用高速演化的需要。&lt;/p&gt;

&lt;h3 id=&quot;service-worker&quot;&gt;&lt;a href=&quot;https://w3c.github.io/ServiceWorker/&quot; title=&quot;Service Worker&quot;&gt;Service Worker&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;我们原有的整个 Web 应用模型，都是构建在「用户能上网」的前提之下的，所以一离线就只能玩小恐龙了。其实，对于「让 web 应用离线执行」这件事，Service Worker 至少是 web 社区的第三次尝试了。&lt;/p&gt;

&lt;p&gt;故事可以追溯到 2007 年的 &lt;a href=&quot;https://en.wikipedia.org/wiki/Google_Gears&quot; title=&quot;Gears - Wikipedia&quot;&gt;Google Gears&lt;/a&gt;：为了让自家的 Gmail、Youtube、Google Reader 等 web 应用可以在本地存储数据与离线执行，Google 开发了一个浏览器拓展来增强 web 应用。Google Gears 支持 IE 6、Safari 3、Firefox 1.5 等浏览器；要知道，那一年 Chrome 都还没出生呢。&lt;/p&gt;

&lt;p&gt;在 Gears API 中，我们通过向 LocalServer 模块提交一个缓存文件清单来实现离线支持：&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Somewhere in your javascript&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;localServer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;google&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;gears&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;factory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;bata.localserver&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;store&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;localServer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;createManagedStore&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;STORE_NAME&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;manifestUrl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;manifest.json&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;manifest.json&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;假设&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;JSON&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;有注释&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;　　&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;betaManifestVersion&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;　&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;　　&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;version&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;　&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;1.0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;　　&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;entries&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;　&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;　&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;　　　　&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;　&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;url&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;　&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;index.html&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;　　　　&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;　&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;url&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;　&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;main.js&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;　　&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;是不是感到很熟悉？好像 &lt;a href=&quot;https://www.w3.org/TR/2011/WD-html5-20110525/offline.html&quot; title=&quot;HTML5 5.6 Offline Web Applications&quot;&gt;HTML5 规范&lt;/a&gt;中的 Application Cache 也是类似的东西？&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;manifest=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;cache.appcache&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CACHE MANIFEST

CACHE:
index.html
main.js
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;是的，Gears 的 LocalServer 就是后来大家所熟知的 App Cache 的前身，大约从 &lt;a href=&quot;https://www.w3.org/TR/offline-webapps/&quot; title=&quot;Offline Web Applications&quot;&gt;2008&lt;/a&gt; 年开始 W3C 就开始尝试将 Gears 进行标准化了；除了 LocalServer，Gears 中用于提供并行计算能力的 WorkerPool 模块与用于提供本地数据库与 SQL 支持的 Database 模块也分别是日后 Web Worker 与 Web SQL Database（后被废弃）的前身。&lt;/p&gt;

&lt;p&gt;HTML5 App Cache 作为第二波「让 web 应用离线执行」的尝试，确实也服务了比如 Google Doc、尤雨溪早年作品 HTML5 Clear、以及一直用 web 应用作为自己 iOS 应用的 FT.com（Financial Times）等不少 web 应用。那么，还有 Service Worker 什么事呢？&lt;/p&gt;

&lt;p&gt;是啊，如果 App Cache 没有被设计得&lt;a href=&quot;https://huangxuan.me/sw-101-gdgdf/#/12&quot; title=&quot;SW-101@DevFest #12&quot;&gt;烂到完全不可编程、无法清理缓存、几乎没有路由机制、出了 Bug 一点救都没有&lt;/a&gt;，可能就真没 Service Worker 什么事了。&lt;a href=&quot;https://huangxuan.me/sw-101-gdgdf/#/13&quot; title=&quot;SW-101@DevFest #13&quot;&gt;App Cache 已经在前不久定稿的 HTML5.1 中被拿掉了，W3C 为了挽救 web 世界真是不惜把自己的脸都打肿了……&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;时至今日，我们终于迎来了 Service Worker 的曙光。简单来说，Service Worker 是一个可编程的 Web Worker，它就像一个位于浏览器与网络之间的客户端代理，可以拦截、处理、响应流经的 HTTP 请求；配合随之引入 Cache Storage API，你可以自由管理 HTTP 请求文件粒度的缓存，这使得 Service Worker 可以从缓存中向 web 应用提供资源，即使是在离线的环境下。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-nextgen-web-pwa/sw-sw.png&quot; alt=&quot;&quot; /&gt;
&lt;em&gt;Service Worker 就像一个运行在客户端的代理&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;比如说，我们可以给网页 &lt;code class=&quot;highlighter-rouge&quot;&gt;foo.html&lt;/code&gt; 注册这么一个 Service Worker，它将劫持由 &lt;code class=&quot;highlighter-rouge&quot;&gt;foo.html&lt;/code&gt; 发起的一切 HTTP 请求，并统统返回未设置 &lt;code class=&quot;highlighter-rouge&quot;&gt;Content-Type&lt;/code&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Hello World!&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// sw.js&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;onfetch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;respondWith&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Hello World!'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Service Worker 第一次发布于 2014 年的 Google IO 上，目前已处于 W3C 工作草案的状态。其设计吸取了 Application Cache 的失败经验，作为 web 应用的开发者的你有着完全的控制能力；同时，它还借鉴了 Chrome 多年来在 Chrome Extension 上的设计经验（Chrome Background Pages 与 Chrome Event Pages），采用了基于「事件驱动」的唤醒机制，以大幅节省后台计算的能耗。比如上面的 &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt; 其实就是会唤醒 Service Worker 的事件之一。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-nextgen-web-pwa/sw-lifecycle.png&quot; alt=&quot;&quot; /&gt;
&lt;em&gt;Service Worker 的生命周期&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;除了类似 &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt; 这样的功能事件外，Service Worker 还提供了一组生命周期事件，包括安装、激活等等。比如，在 Service Worker 的「安装」事件中，我们可以把 web 应用所需要的资源统统预先下载并缓存到 Cache Storage 中去：&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// sw.js&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;oninstall&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;waitUntil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;caches&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'installation'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;cache&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;  &lt;span class=&quot;nx&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;addAll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;
        &lt;span class=&quot;s1&quot;&gt;'./'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s1&quot;&gt;'./styles.css'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s1&quot;&gt;'./script.js'&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样，当用户离线，网络无法访问时，我们就可以从缓存中启动我们的 web 应用：&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//sw.js&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;onfetch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;fetched&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cached&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;caches&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;match&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;nx&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;respondWith&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;fetched&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cached&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看出，Service Worker 被设计为一个相对底层（low-level）、高度可编程、子概念众多，也因此异常灵活且强大的 API，故本文只能展示它的冰山一角。出于安全考虑，注册 Service Worker 要求你的 web 应用部署于 HTTPS 协议下，以免利用 Service Worker 的中间人攻击。笔者在今年 GDG 北京的 DevFest 上分享了 &lt;a href=&quot;https://huangxuan.me/2016/11/20/sw-101-gdgdf/&quot;&gt;Service Worker 101&lt;/a&gt;，涵盖了 Service Worker 譬如「网络优先」、「缓存优先」、「网络与缓存比赛」这些更复杂的缓存策略、学习资料、以及&lt;a href=&quot;https://github.com/Huxpro/sw-101-gdgdf&quot;&gt;示例代码&lt;/a&gt;，可以供大家参考。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-nextgen-web-pwa/sw-race.png&quot; alt=&quot;&quot; /&gt;
&lt;em&gt;Service Worker 的一种缓存策略：让网络请求与读取缓存比赛&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;你也可以尝试在支持 PWA 的浏览器中访问笔者的博客 &lt;a href=&quot;https://huangxuan.me&quot; title=&quot;Hux Blog&quot;&gt;Hux Blog&lt;/a&gt;，感受 Service Worker 的实际效果：所有访问过的页面都会被缓存并允许在离线环境下继续访问，所有未访问过的页面则会在离线环境下展示一个自定义的离线页面。&lt;/p&gt;

&lt;p&gt;在笔者看来，&lt;strong&gt;Service Worker 对 PWA 的重要性相当于 &lt;code class=&quot;highlighter-rouge&quot;&gt;XMLHTTPRequest&lt;/code&gt; 之于 Ajax，媒体查询（Media Query）之于响应式设计，是支撑 PWA 作为「下一代 web 应用模型」的最核心技术。&lt;/strong&gt;由于 Service Worker 可以与包括 Indexed DB、Streams 在内的大部分 DOM 无关 API 进行交互，它的潜力简直无可限量。笔者几乎可以断言，Service Worker 将在未来十年里成为 web 客户端技术工程化的兵家必争之地，带来「离线优先（Offline-first）」的架构革命。&lt;/p&gt;

&lt;h3 id=&quot;push-notification&quot;&gt;Push Notification&lt;/h3&gt;

&lt;p&gt;PWA 推送通知中的「推送」与「通知」，其实使用的是两个不同但又相得益彰的 API：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://notifications.spec.whatwg.org/&quot; title=&quot;Notification API&quot;&gt;Notification API&lt;/a&gt; 相信大家并不陌生，它负责所有与通知本身相关的机制，比如通知的权限管理、向操作系统发起通知、通知的类型与音效，以及提供通知被点击或关闭时的回调等等，目前国内外的各大网站（尤其在桌面端）都有一定的使用。Notification API 最早应该是在 &lt;a href=&quot;https://www.html5rocks.com/en/tutorials/notifications/quick/&quot; title=&quot;Using the Notification API&quot;&gt;2010&lt;/a&gt; 年前后由 Chromium 提出&lt;a href=&quot;http://www.chromium.org/developers/design-documents/desktop-notifications/api-specification&quot; title=&quot;API Specification - The Chromium Projects&quot;&gt;草案&lt;/a&gt;以 &lt;code class=&quot;highlighter-rouge&quot;&gt;webkitNotifications&lt;/code&gt; 前缀方式实现；随着 2011 年进入标准化；2012 年在 Safari 6（Mac OSX 10.8+）上获得支持；2015 年 Notification API 成为 &lt;a href=&quot;https://www.w3.org/TR/notifications/&quot; title=&quot;Web Notifications - W3C&quot;&gt;W3C Recommendation&lt;/a&gt;；2016 年 &lt;a href=&quot;https://blogs.windows.com/msedgedev/2016/05/16/web-notifications-microsoft-edge/#2VBm890EjvAvUcgE.97&quot;&gt;Edge 的支持&lt;/a&gt;；Web Notifications 已经在桌面浏览器中获得了全面支持（Chrome、Edge、Firefox、Opera、Safari）的成就。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://w3c.github.io/push-api/&quot; title=&quot;Push API&quot;&gt;Push API&lt;/a&gt; 的出现则让推送服务具备了向 web 应用推送消息的能力，它定义了 web 应用如何向推送服务发起订阅、如何响应推送消息，以及 web 应用、应用服务器与推送服务之间的鉴权与加密机制；由于 Push API 并不依赖 web 应用与浏览器 UI 存活，所以即使是在 web 应用与浏览器未被用户打开的时候，也可以通过后台进程接受推送消息并调用 Notification API 向用户发出通知。值得一提的是，Mac OSX 10.9 Mavericks 与 Safari 7 在 2013 年就发布了自己的私有推送支持，基于 APNS 的 &lt;a href=&quot;https://developer.apple.com/notifications/safari-push-notifications/&quot; title=&quot;Safari Push Notifications&quot;&gt;Safari Push Notifications&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;在 PWA 中，我们利用 Service Worker 的后台计算能力结合 Push API 对推送事件进行响应，并通过 Notification API 实现通知的发出与处理：&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// sw.js&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;addEventListener&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'push'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;waitUntil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Process the event and display a notification.&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;registration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;showNotification&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Hey!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;addEventListener&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'notificationclick'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  
  &lt;span class=&quot;c1&quot;&gt;// Do something with the event  &lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;notification&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;  
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;addEventListener&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'notificationclose'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  
  &lt;span class=&quot;c1&quot;&gt;// Do something with the event  &lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对于 Push Notification，笔者的几次分享中一直都提的稍微少一些，一是因为 Push API 还处于 Editor Draft 的状态，二是目前浏览器与推送服务的互相支持都还不够成熟：Android 上的 Chrome（与其它基于 Blink 的浏览器）目前只支持基于 Google 私有的 GCM/FCM 的通知推送，只有 Firefox 已经实现了正在由 IETF 进行标准化的 &lt;a href=&quot;https://tools.ietf.org/html/draft-ietf-webpush-protocol-12&quot; title=&quot;Web Push Protocol&quot;&gt;Web 推送协议（Web Push Protocol）&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;不过，如果你已经在使用 Google 的云服务（比如 Firebase），并且主要面向的是海外用户，那么在 web 应用上支持基于 GCM/FCM 的推送通知并不是一件费力的事情，笔者推荐你阅读一下 Google Developers 的&lt;a href=&quot;https://developers.google.com/web/fundamentals/engage-and-retain/push-notifications/&quot; title=&quot;Web Push Notifications - Google Developer&quot;&gt;系列文章&lt;/a&gt;，很多国外公司已经玩起来了。&lt;/p&gt;

&lt;h2 id=&quot;从-hybrid-到-pwa从封闭到开放&quot;&gt;从 Hybrid 到 PWA，从封闭到开放&lt;/h2&gt;

&lt;p&gt;2008 年，当移动时代来临，&lt;a href=&quot;https://huangxuan.me/pwa-qcon2016/#/17&quot; title=&quot;PWA@QCon2016 #17&quot;&gt;唱衰移动 Web 的声音&lt;/a&gt;开始出现，而浏览器的进化并不能跟上时，来自 Nitobi 的 Brian Leroux 等人创造了 &lt;a href=&quot;https://cordova.apache.org/&quot; title=&quot;Apache Cordova&quot;&gt;Phonegap&lt;/a&gt;，希望它能以 Polyfill 的形式、弥补目前浏览器与移动设备间的「鸿沟」，从此开启了&lt;a href=&quot;https://en.wikipedia.org/wiki/Progressive_web_app#Hybrid_Apps&quot;&gt;混合应用（Hybrid Apps）&lt;/a&gt;的时代。&lt;/p&gt;

&lt;p&gt;几年间，&lt;a href=&quot;http://www.adobe.com/products/air.html&quot; title=&quot;Adobe AIR Application&quot;&gt;Adobe AIR&lt;/a&gt;、&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/apps/br211385.aspx&quot; title=&quot;Windows Runtime JS API&quot;&gt;Windows Runtime Apps&lt;/a&gt;、&lt;a href=&quot;https://developer.chrome.com/extensions/apps&quot; title=&quot;Chrome Packaged Apps&quot;&gt;Chrome Apps&lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Archive/Firefox_OS/Firefox_OS_apps/Building_apps_for_Firefox_OS&quot; title=&quot;Firefox OS Packaged Apps&quot;&gt;Firefox OS&lt;/a&gt;、&lt;a href=&quot;http://www.openwebosproject.org/&quot; title=&quot;Open webOS&quot;&gt;WebOS&lt;/a&gt;、&lt;a href=&quot;https://cordova.apache.org/&quot; title=&quot;Apache Cordova&quot;&gt;Cordova/Phonegap&lt;/a&gt;、&lt;a href=&quot;http://electron.atom.io/&quot; title=&quot;Electron&quot;&gt;Electron&lt;/a&gt; 以及国内比如微信、淘宝，无数的 Hybrid 方案拔地而起，让 web 开发者可以在继续使用 web 客户端技术的同时，做到一些只有原生应用才能做到的事情，包括访问一些设备与操作系统 API，给用户带来更加 「Appy」 的体验，以及进入 App Store 等等。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-nextgen-web-pwa/qcon-hybridzation.png&quot; alt=&quot;&quot; /&gt;
&lt;em&gt;众多的 Hybrid 方案&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;PWA 作为一个涵盖性术语，与过往的这些或多或少通过私有平台 API 增强 web 应用的尝试最大的不同，在于构成 PWA 的每一项基本技术，都已经或正在被 IETF、ECMA、W3C 或 WHATWG 标准化，不出意外的话，它们都将被纳入开放 web 标准，并在不远的将来得到所有浏览器与全平台的支持。我们终于可以逃出 App Store 封闭的秘密花园，重新回到属于 web 的那片开放自由的大地。&lt;/p&gt;

&lt;p&gt;有趣的是，从上文中你也可以发现，组成 PWA 的各项技术的草案正是由上述各种私有方案背后的浏览器厂商或开发者直接贡献或间接影响的。可以说，PWA 的背后并不是某一家或两家公司，而是整个 web 社区与整个 web 规范。&lt;strong&gt;正是因为这种开放与去中心化的力量，使得万维网（World Wide Web）能够成为当今世界上跨平台能力最强、且几乎是唯一一个具备这种跨平台能力的应用平台。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://phonegap.com/blog/2012/05/09/phonegap-beliefs-goals-and-philosophy/&quot; title=&quot;PhoneGap Beliefs, Goals, and Philosophy&quot;&gt;「我们相信 Web，是因为相信它是解决设备差异化的终极方案；我们相信，当 Web 在今天做不到一件事的时候，是因为它还没来得及去实现，而不是因为他做不到。而 Phonegap，它的终极目的就是消失在 Web 标准的背后。」&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在不丢失 web 的开放灵魂，在不需要依靠 Hybrid 把应用放在 App Store 的前提下，让 web 应用能够渐进式地跳脱出浏览器的标签，变成用户眼中的 App。这是 Alex Russell 在 2015 年提出 PWA 概念的&lt;a href=&quot;https://infrequently.org/2015/06/progressive-apps-escaping-tabs-without-losing-our-soul/&quot; title=&quot;Progressive Web Apps: Escaping Tabs Without Losing Our Soul&quot;&gt;原委&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;而又正因为 web 是一个整体，PWA 可以利用的技术远不止上述的几个而已：Ajax、响应式设计、JavaScript 框架、ECMAScript Next、CSS Next、Houdini、Indexed DB、Device APIs、Web Bluetooth、Web Socket、Web Payment、&lt;a href=&quot;https://wicg.github.io/BackgroundSync/spec/&quot; title=&quot;Web Background Synchronization - WICG&quot;&gt;孵化&lt;/a&gt;中的 &lt;a href=&quot;developers.google.com/web/updates/2015/12/background-sync&quot; title=&quot;Background Sync - Google Developers&quot;&gt;Background Sync API&lt;/a&gt;、&lt;a href=&quot;https://streams.spec.whatwg.org/&quot; title=&quot;Streams&quot;&gt;Streams&lt;/a&gt;、WebVR……开放 Web 世界 27 年来的发展以及未来的一切，都与 PWA 天作之合。&lt;/p&gt;

&lt;h2 id=&quot;鱼与熊掌的兼得&quot;&gt;鱼与熊掌的兼得&lt;/h2&gt;

&lt;p&gt;经过几年来的摸索，整个互联网行业仿佛在「Web 应用 vs. 原生应用」这个问题上达成了共识：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;web 应用是鱼：迭代快，获取用户成本低；跨平台强体验弱，开发成本低。&lt;strong&gt;适合拉新&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;原生应用是熊掌：迭代慢，获取用户成本高；跨平台弱体验强，开发成本高。&lt;strong&gt;适合保活&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;要知道，虽然用户花在原生应用上的时间要明显多于 web 应用，但其中&lt;a href=&quot;http://marketingland.com/report-mobile-users-spend-80-percent-time-just-five-apps-116858&quot; title=&quot;Report: Mobile Users Spend 80 Percent Of Time In Just Five Apps&quot;&gt;有 80% 的时间是花在前五个应用中的&lt;/a&gt;。&lt;a href=&quot;http://www.recode.net/2016/9/16/12933780/average-app-downloads-per-month-comscore&quot; title=&quot;Half of U.S. smartphone users download zero apps per month&quot;&gt;调查显示，美国有一半的智能手机用户平均每月新 App 安装量为零&lt;/a&gt;，而月均网站访问量却有 100 个，更别提 Google Play 上&lt;a href=&quot;https://youtu.be/EUthgV-U05w&quot; title=&quot;AdWords for App Promotion - Google&quot;&gt;有 60% 的应用从未被人下载过了&lt;/a&gt;。于是，整个行业的产品策略清一色地&lt;strong&gt;「拿鱼换熊掌」&lt;/strong&gt;，比如笔者的老东家阿里旅行（飞猪旅行），web 应用布满阿里系各种渠道，提供「优秀的第一手体验」，等你用的开心了，再引诱你去下载安装原生应用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-nextgen-web-pwa/PWAR-014+PWA.jpeg&quot; alt=&quot;&quot; /&gt;
&lt;em&gt;原生应用、当代 Web 与 PWA 图片来源: Hux &amp;amp; &lt;a href=&quot;https://developers.google.com/web/events/pwaroadshow/&quot;&gt;Google&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;但是，PWA 的出现，让鱼与熊掌兼得变成了可能 —— 它同时具备了 web 应用与原生应用的优点，有着自己独有的先进性：「浏览器 -&amp;gt; 添加至主屏/安装 -&amp;gt; 具备原生应用体验的 PWA -&amp;gt; 推送通知 -&amp;gt; 具备原生应用体验的 PWA」，PWA 自身就包含着从拉新到保活的闭环。&lt;/p&gt;

&lt;p&gt;除此之外，PWA 还继承了 web 应用的另外两大优点：&lt;strong&gt;无需先付出几十兆的下载安装成本即可开始使用&lt;/strong&gt;，以及&lt;strong&gt;不需要经过应用超市审核就可以发布新版本&lt;/strong&gt;。所以，PWA 可以称得上是一种「流式应用（Streamable App）」与「常青应用（Evergreen App）」&lt;/p&gt;

&lt;h2 id=&quot;未来到来了吗&quot;&gt;未来到来了吗&lt;/h2&gt;

&lt;p&gt;在笔者分享 PWA 的经历中，最不愿意回答的两个问题莫过于「PWA 已经被广泛支持了吗？」以及「PWA 与 ABCDEFG 这些技术方案相比有什么优劣？」，但是这确实是两个逃不开的问题。&lt;/p&gt;

&lt;h3 id=&quot;pwa-的支持情况&quot;&gt;PWA 的支持情况？&lt;/h3&gt;

&lt;p&gt;当我们说到 PWA 是否被支持时，其实我们在说的是 PWA 背后的几个关键技术都得到支持了没有。以浏览器内核来划分的话，Blink（Chrome、Oprea、Samsung Internet 等）与 Gecko（Firefox）都已经实现了 PWA 所需的所有关键技术（👏👏👏），并已经开始探寻更多的可能性。EdgeHTML（Edge）&lt;a href=&quot;https://blogs.windows.com/msedgedev/2016/07/08/the-progress-of-web-apps/&quot; title=&quot;The Progress of Web Apps - MSEdgeDev Blog&quot;&gt;简直积极得不能更积极了&lt;/a&gt;，所有的特性都已经处于「正在开发中」的&lt;a href=&quot;https://developer.microsoft.com/en-us/microsoft-edge/platform/status/&quot; title=&quot;Microsoft Edge web platform features status&quot;&gt;状态&lt;/a&gt;。最大的绊脚石仍然来自于 Webkit（Safari），尤其是在 iOS 上，上述的四个 API 都未得到支持，而且由于平台限制，第三方浏览器也无法在 iOS 上支持。（&lt;a href=&quot;https://www.microsoft.com/en-us/WindowsForBusiness/End-of-IE-support&quot; title=&quot;Internet Explorer End of Support&quot;&gt;什么你说 IE？&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;不过，也不要气馁，Webkit 不但在它 &lt;a href=&quot;https://trac.webkit.org/wiki/FiveYearPlanFall2015&quot;&gt;2015 年发布的五年计划&lt;/a&gt;里提到了 Service Worker，更是已经在最近实现了 Service Worker 所&lt;a href=&quot;https://jakearchibald.github.io/isserviceworkerready/&quot; title=&quot;Is Service Worker Ready?&quot;&gt;依赖&lt;/a&gt;的 Request、Response 与 Fetch API，还把 Service Worker 与 Web App Manifest 纷纷&lt;a href=&quot;https://webkit.org/status/&quot; title=&quot;Webkit Feature Status&quot;&gt;列入了「正在考虑」&lt;/a&gt;的 API 中；要知道，Webkit 可是把 Web Components 中的 HTML Imports 直接&lt;a href=&quot;https://webkit.org/status/#specification-web-components&quot; title=&quot;HTML Imports - Not Considering&quot;&gt;列到「不考虑」里去了&lt;/a&gt;……（其实 Firefox 也是）&lt;/p&gt;

&lt;p&gt;更何况，由于 web 社区一直以来所追求的「渐进增强、优雅降级」，一个 PWA 当然可以在 iOS 环境正常执行。&lt;a href=&quot;https://cloudfour.com/thinks/why-does-the-washington-posts-progressive-web-app-increase-engagement-on-ios/&quot; title=&quot;Why does The Washington Post’s Progressive Web App increase engagement on iOS?&quot;&gt;事实上，华盛顿邮报将网站迁移到 PWA 之后发现，不止是 Android，在 iOS 上也获得了 5 倍的活跃度增长&lt;/a&gt;，（无论是不是它们之前的网站写得太烂吧），就算 iOS 现在还不支持 PWA 也&lt;a href=&quot;https://cloudfour.com/thinks/ios-doesnt-support-progressive-web-apps-so-what/&quot; title=&quot;iOS doesn’t support Progressive Web Apps, so what?&quot;&gt;不会怎么样&lt;/a&gt;，我们更是有理由相信 PWA 会很快在 iOS 上到来。&lt;/p&gt;

&lt;h3 id=&quot;pwa-vs-others&quot;&gt;PWA vs. Others&lt;/h3&gt;

&lt;p&gt;贺老（贺师俊）曾说过：「从纯 Web 到纯 Native，之间有许多可能的点」。当考虑移动应用的技术选型时，除了 Web 与原生应用，我们还有各种不同程度的 Hybrid，还有今年爆发的诸多 JS-to-Native 方案。&lt;/p&gt;

&lt;p&gt;虽然我在上文中用了「复仇」这样的字眼，不过无论从技术还是商业的角度，我们都没必要把 web 或是 PWA 放到 Native 的对立面去看。它们当然存在竞争关系，但是更多的时候，web-only 与 app-only 的策略都是不完美的，当公司资源足够的时候，我们通常会选择同时开发两者。&lt;a href=&quot;https://cloudfour.com/thinks/progressive-web-apps-simply-make-sense/?utm_source=mobilewebweekly&amp;amp;utm_medium=email#fn-4857-1&quot; title=&quot;Progressive Web Apps Simply Make Sense&quot;&gt;当然，无论与不与原生应用对比，PWA 让 web 应用变得体验更好这件事本身是毋庸置疑的。&lt;/a&gt;「不谈场景聊技术都是扯淡」，&lt;a href=&quot;https://medium.com/@owencm/the-surprising-tradeoff-at-the-center-of-question-whether-to-build-an-native-or-web-app-d2ad00c40fb2#.ym83ct2ax&quot; title=&quot;The surprising tradeoff at the center of the question whether to build a Native or Web App&quot;&gt;我们仍然还是需要根据自己产品与团队的情况来决定对应的技术选型与平台策略，只是 PWA 让 web 应用在面对选型考验时更加强势了而已。&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-nextgen-web-pwa/qcon-trend.png&quot; alt=&quot;&quot; /&gt;
&lt;em&gt;众多的技术选型，以及笔者的一种猜测&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;笔者不负责任得做一些猜测：虽然&lt;a href=&quot;http://zhihu.com/question/31316032/answer/75236718&quot;&gt;重量级的 Hybrid 架构与基础设施&lt;/a&gt;仍是目前不少场景下最优的解决方案；但是随着移动设备本身的硬件性能提升与新技术的成熟与普及，JS-to-Native 与以 PWA 为首的纯 web 应用，将分别从两个方向挤压 Hybrid 的生存空间，消化当前 Hybrid 架构主要解决的问题；前者将逐渐演化为类似 Xarmarin 这样针对跨平台原生应用开发的解决方案；后者将显著降低当前 Hybrid 架构的容器开发与部署成本，将 Hybrid 返璞归真为简单的 webview 调用。&lt;/p&gt;

&lt;p&gt;这种猜测当然不是没有依据的瞎猜，比如前者可以参考阿里巴巴集团级别迁移 Weex 的战略与微信小程序的 roadmap；后者则可以参考当前 Cordova 与 Ionic 两大 Hybrid 社区对 PWA 的热烈反响。&lt;/p&gt;

&lt;h3 id=&quot;pwa-in-china&quot;&gt;PWA in China&lt;/h3&gt;

&lt;p&gt;看看 Google 官方宣传较多的 PWA &lt;a href=&quot;https://developers.google.com/web/showcase/&quot; title=&quot;Case Studies - Google Developers&quot;&gt;案例&lt;/a&gt;就会发现，FlipKart、Housing.com 来自印度；Uber、华盛顿邮报来自北美；唯一来自中国的 AliExpress 主要开展的则是海外业务。&lt;/p&gt;

&lt;p&gt;由于中国的特殊性，笔者在&lt;a href=&quot;https://www.zhihu.com/question/46690207/answer/104851767&quot;&gt;第一次&lt;/a&gt;聊到 PWA 时难免表现出了一定程度的悲观：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;国内较重视 iOS，而 iOS 目前还不支持 PWA。&lt;/li&gt;
  &lt;li&gt;国内的 Android 实为「安卓」，不自带 Chrome 是一，可能还会有其他兼容问题。&lt;/li&gt;
  &lt;li&gt;国内厂商可能并不会像三星那样对推动自家浏览器支持 PWA 那么感兴趣。&lt;/li&gt;
  &lt;li&gt;依赖 GCM 推送的通知不可用，Web Push Protocol 还没有国内的推送服务实现。&lt;/li&gt;
  &lt;li&gt;国内 webview 环境较为复杂（比如微信），黑科技比较多。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;反观印度，由于 Google 服务健全、标配 Chrome 的 Android 手机市占率非常高，PWA 的用户达到率简直直逼 100%，也难免获得无数好评与支持了。&lt;strong&gt;笔者奢望着本文能对推动 PWA 的国内环境有一定的贡献。&lt;/strong&gt;不过无论如何，PWA 在国内的春天可能的确会来得稍微晚一点了。&lt;/p&gt;

&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;

&lt;p&gt;「&lt;a href=&quot;https://huangxuan.me/pwa-qcon2016/#/99&quot; title=&quot;PWA@QCon2016 #97&quot;&gt;我们信仰 Web，不仅仅在于软件、软件平台与单纯的技术&lt;/a&gt;，还在于&lt;a href=&quot;http://phonegap.com/blog/2012/05/09/phonegap-beliefs-goals-and-philosophy/&quot; title=&quot;PhoneGap Beliefs, Goals, and Philosophy&quot;&gt;『任何人，在任何时间任何地点，都可以在万维网上发布任何信息，并被世界上的任何一个人所访问到。』而这才是 web 的最为革命之处，堪称我们人类，作为一个物种的一次进化。&lt;/a&gt;」&lt;/p&gt;

&lt;p&gt;请不要让 web 再&lt;a href=&quot;https://zhuanlan.zhihu.com/p/22561084&quot; title=&quot;Web 在继续离我们远去&quot;&gt;继续离我们远去&lt;/a&gt;，浏览器厂商们已经重新走到了一起，而下一棒将是交到我们 web 应用开发者的手上。&lt;a href=&quot;youtu.be/y1B2c3ZD9fk?t=1h14m48s&quot; title=&quot;WWDC 2017&quot;&gt;乔布斯曾相信 web 应用才移动应用的未来&lt;/a&gt;，那就让我们用代码证明给这个世界看吧。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;让我们的用户，也像我们这般热爱 web 吧。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;黄玄，于 12 月的北京。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;注：在笔者撰文期间，Google 在 Google China Developers Days 上宣布了 developers.google.cn 域名的启用，方便国内开发者访问。对于文中所有链向 developers.google.com 的参考文献，应该都可以在 cn 站点中找到。&lt;/em&gt;&lt;/p&gt;

</description>
        <pubDate>Thu, 09 Feb 2017 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/02/09/nextgen-web-pwa/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/02/09/nextgen-web-pwa/</guid>
        
        <category>前端开发</category>
        
        <category>JavaScript</category>
        
        <category>PWA</category>
        
        
      </item>
    
      <item>
        <title>Service Worker 101「GDG DevFest 2016 北京」</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;下滑这里查看更多内容&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;TLDR; It covers lots of cool stuff about Service Worker!&lt;/p&gt;

&lt;h3 id=&quot;watching-fullscreen--&quot;&gt;&lt;a href=&quot;https://huangxuan.me/sw-101-gdgdf/&quot;&gt;Watching Fullscreen → &lt;/a&gt;&lt;/h3&gt;

&lt;div class=&quot;visible-md visible-lg&quot;&gt;
    &lt;img src=&quot;//huangxuan.me/sw-101-gdgdf/attach/qrcode.png&quot; width=&quot;350&quot; /&gt;
    &lt;small class=&quot;img-hint&quot;&gt;Scanning on mobile&lt;/small&gt;
&lt;/div&gt;

&lt;h3 id=&quot;demo-code--&quot;&gt;&lt;a href=&quot;https://github.com/Huxpro/sw-101-gdgdf&quot;&gt;Demo Code → &lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Hello World of Service Worker&lt;/li&gt;
  &lt;li&gt;Make your own Offline Dinosaurs&lt;/li&gt;
  &lt;li&gt;Stale/Fastest while revalidate&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;notes&quot;&gt;Notes&lt;/h3&gt;

&lt;p&gt;This slides is powered by &lt;a href=&quot;http://yanshuo.io&quot;&gt;Yanshuo.io (演说.io)&lt;/a&gt;, a online software helping you create, store and share web slides.&lt;/p&gt;

&lt;p&gt;There are 2 ways that you can fork or contribute this project:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;index.html&lt;/code&gt; is the HTML source code exported from &lt;a href=&quot;http://yanshuo.io&quot;&gt;Yanshuo.io&lt;/a&gt;, and many of its dependencis (js, css, fonts) are still linked to CDN of &lt;a href=&quot;http://yanshuo.io&quot;&gt;Yanshuo.io&lt;/a&gt;. You can do any secondary development and host it by yourself.&lt;/li&gt;
  &lt;li&gt;Download the project file under &lt;code class=&quot;highlighter-rouge&quot;&gt;shuo/&lt;/code&gt;, drag it into &lt;a href=&quot;http://yanshuo.io&quot;&gt;Yanshuo.io&lt;/a&gt;, and you are ready to go. You can edit whatever you want, upload it to your account, and even share your distributions.&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Sun, 20 Nov 2016 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2016/11/20/sw-101-gdgdf/</link>
        <guid isPermaLink="true">http://localhost:4000/2016/11/20/sw-101-gdgdf/</guid>
        
        <category>前端开发</category>
        
        <category>JavaScript</category>
        
        <category>PWA</category>
        
        <category>Service Worker</category>
        
        
      </item>
    
      <item>
        <title>Progressive Web Apps，复兴序章「QCon 上海 2016」</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;下滑这里查看更多内容&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;watching-fullscreen-&quot;&gt;&lt;a href=&quot;https://huangxuan.me/pwa-qcon2016/&quot;&gt;Watching Fullscreen →&lt;/a&gt;&lt;/h3&gt;

&lt;div class=&quot;visible-md visible-lg&quot;&gt;
    &lt;img src=&quot;//huangxuan.me/pwa-qcon2016/attach/qrcode.png&quot; width=&quot;350&quot; /&gt;
    &lt;small class=&quot;img-hint&quot;&gt;Scanning on mobile&lt;/small&gt;
&lt;/div&gt;

&lt;h3 id=&quot;catalog&quot;&gt;Catalog&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;The State Of Web&lt;/li&gt;
  &lt;li&gt;Rethinking Hybridzation&lt;/li&gt;
  &lt;li&gt;PWA 101
    &lt;ul&gt;
      &lt;li&gt;Definition&lt;/li&gt;
      &lt;li&gt;Add To HomeScreen
        &lt;ul&gt;
          &lt;li&gt;Web Manifest&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Reliable Experience (Network as PE)
        &lt;ul&gt;
          &lt;li&gt;Service Worker
            &lt;ul&gt;
              &lt;li&gt;Register SW&lt;/li&gt;
              &lt;li&gt;On Install &amp;amp; Cache API
                &lt;ul&gt;
                  &lt;li&gt;ExtendableEvent &amp;amp; SkipWaiting&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;On Fetch&lt;/li&gt;
              &lt;li&gt;Stale-While-Revalidate &amp;amp; Fallback&lt;/li&gt;
              &lt;li&gt;Updating SW&lt;/li&gt;
              &lt;li&gt;SW LifeCycle&lt;/li&gt;
              &lt;li&gt;On Activate&lt;/li&gt;
              &lt;li&gt;SW Brings Architectural Revolution&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Re-engageable&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;PWA In Production
    &lt;ul&gt;
      &lt;li&gt;User Expectation &amp;amp; Guiding&lt;/li&gt;
      &lt;li&gt;Low Deliver Friction&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;PWA vs. Others&lt;/li&gt;
  &lt;li&gt;The Belief In Web
    &lt;ul&gt;
      &lt;li&gt;One Web&lt;/li&gt;
      &lt;li&gt;Fulfill WWDC 2007&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;notes&quot;&gt;Notes&lt;/h3&gt;

&lt;p&gt;This slides is powered by &lt;a href=&quot;http://yanshuo.io&quot;&gt;Yanshuo.io (演说.io)&lt;/a&gt;, a online software helping you create, store and share web slides.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;index.html&lt;/code&gt; is the HTML source code exported from &lt;a href=&quot;http://yanshuo.io&quot;&gt;Yanshuo.io&lt;/a&gt;, and many of its dependencis (js, css, fonts) are still linked to CDN of &lt;a href=&quot;http://yanshuo.io&quot;&gt;Yanshuo.io&lt;/a&gt;. You can do any secondary development and host it by yourself.&lt;/p&gt;

</description>
        <pubDate>Thu, 20 Oct 2016 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2016/10/20/pwa-qcon2016/</link>
        <guid isPermaLink="true">http://localhost:4000/2016/10/20/pwa-qcon2016/</guid>
        
        <category>前端开发</category>
        
        <category>JavaScript</category>
        
        <category>PWA</category>
        
        
      </item>
    
      <item>
        <title>Progressive Web App 之我见</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;下滑这里查看更多内容&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;watching-fullscreen-&quot;&gt;&lt;a href=&quot;https://huangxuan.me/pwa-in-my-pov/&quot;&gt;Watching Fullscreen →&lt;/a&gt;&lt;/h3&gt;

&lt;div class=&quot;visible-md visible-lg&quot;&gt;
    &lt;img src=&quot;//huangxuan.me/pwa-in-my-pov/attach/qrcode.png&quot; width=&quot;350&quot; /&gt;
    &lt;small class=&quot;img-hint&quot;&gt;Scanning on mobile&lt;/small&gt;
&lt;/div&gt;

&lt;h3 id=&quot;catalog&quot;&gt;Catalog&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;WHAT is Progressive Web App?&lt;/li&gt;
  &lt;li&gt;1 - Installability&lt;/li&gt;
  &lt;li&gt;2 - App Shell&lt;/li&gt;
  &lt;li&gt;3 - Offline
    &lt;ul&gt;
      &lt;li&gt;SERVICE WORKER!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;4 - Re-engageable
    &lt;ul&gt;
      &lt;li&gt;Push Notification&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CONS in my pov&lt;/li&gt;
  &lt;li&gt;PROS in my pov&lt;/li&gt;
  &lt;li&gt;Why Web?&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;power-by-yanshuoio演说io&quot;&gt;Power by &lt;a href=&quot;https://yanshuo.io&quot;&gt;Yanshuo.io（演说.io）&lt;/a&gt;&lt;/h3&gt;
</description>
        <pubDate>Sun, 05 Jun 2016 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2016/06/05/pwa-in-my-pov/</link>
        <guid isPermaLink="true">http://localhost:4000/2016/06/05/pwa-in-my-pov/</guid>
        
        <category>前端开发</category>
        
        <category>JavaScript</category>
        
        <category>PWA</category>
        
        
      </item>
    
      <item>
        <title>React vs Angular 2：冰与火之歌「译」</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;这篇文章转载自&lt;a href=&quot;http://zhuanlan.zhihu.com/FrontendMagazine/20549104&quot;&gt;我在知乎专栏「前端外刊评论」上发表的文章&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://angular.io/&quot;&gt;Angular 2&lt;/a&gt; 已经发布 Beta 版，而且似乎很有信心在 2016 年成为热门框架。是时候进行一场巅峰对决了，我们来看看它如何与 &lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;React&lt;/a&gt; 这个 2015 年的新宠抗衡。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;免责声明：&lt;/strong&gt;我之前很喜欢使用 Angular 1，不过在 2015 年转到了 React。最近我也在 Pluralsight 上发布了一门关于 &lt;a href=&quot;https://www.pluralsight.com/courses/react-flux-building-applications&quot;&gt;React 和 Flux 的课程&lt;/a&gt;（&lt;a href=&quot;http://app.pluralsight.com/signup&quot;&gt;免费试学&lt;/a&gt;）。所以，&lt;strong&gt;是的，我本人是有偏见的，但我不会偏袒任何一方。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;好了，我们开始吧，这场对决将会非常血腥。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*MRPl_SNuRGJchb6eOAnkSA.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图片来源：&lt;a href=&quot;https://twitter.com/jwcarroll&quot;&gt;@jwcarrol&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;两者根本不具有可比性&quot;&gt;两者根本不具有可比性！&lt;/h2&gt;

&lt;p&gt;是的是的，Angular 是框架，React 是类库。所以有人觉得比较这两者没有逻辑性可言。大错特错！&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;选择 Angular 还是 React 就像选择直接购买成品电脑还是买零件自己组装一样。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;两者的优缺点本文都会提及，我会拿 React 语法和组件模型跟 Angular 的语法和组件模型做对比。这就像是拿成品电脑的 CPU 跟零售的 CPU 做对比，没有任何不妥。&lt;/p&gt;

&lt;h2 id=&quot;angular-2-的优点&quot;&gt;Angular 2 的优点&lt;/h2&gt;

&lt;p&gt;我们先看 Angular 相对 React 有哪些优势。&lt;/p&gt;

&lt;h4 id=&quot;无选择性疲劳&quot;&gt;&lt;strong&gt;无选择性疲劳&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;Angular 是一个完整的框架，本身就提供了比 React 多得多的建议和功能。而要用 React，开发者通常还需要借助别的类库来打造一个真正的应用。比如你可能需要额外的库来处理路由、强制单向数据流、进行 API 调用、做测试以及管理依赖等等。要做的选择和决定太多了，让人很有压力。这也是为什么 React 有那么多的入门套件的原因（我自己就写了两个：&lt;a href=&quot;https://github.com/coryhouse/react-flux-starter-kit&quot;&gt;1&lt;/a&gt;、&lt;a href=&quot;https://github.com/coryhouse/react-slingshot&quot;&gt;2&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;Angular 自带了不少主张，所以能够帮助你更快开始，不至于因为要做很多决定而无所适从。这种强制的一致性也能帮助新人更快适应其开发模式，并使得开发者在不同团队间切换更具可行性。&lt;/p&gt;

&lt;p&gt;Angular 核心团队让我非常欣赏的一点是，他们拥抱了 TypeScript，这就造成了另一个优势。&lt;/p&gt;

&lt;h4 id=&quot;typescript--阳关大道&quot;&gt;TypeScript = 阳关大道&lt;/h4&gt;

&lt;p&gt;没错，并非所有人都喜欢 TypeScript，但是 Angular 2 毅然决然地选择了它确实是个巨大的优势。反观 React，网上的各种示例应用令人沮丧地不一致——ES5 和 ES6 的项目基本上各占一半，而且目前存在&lt;a href=&quot;http://jamesknelson.com/should-i-use-react-createclass-es6-classes-or-stateless-functional-components/&quot;&gt;三种不同的组件声明方式&lt;/a&gt;。这无疑给初学者造成了困惑。（Angular 还拥抱了装饰器（decorator）而不是继承（extends）——很多人认为这也是个加分项）。&lt;/p&gt;

&lt;p&gt;尽管 Angular 2 并不强制使用 TypeScript，但显然的是，Angular 的核心团队默认在文档中使用 TypeScript。这意味着相关的示例应用和开源项目更有可能保持一致性。Angular 已经提供了&lt;a href=&quot;https://angular.io/docs/ts/latest/quickstart.html&quot;&gt;非常清晰的关于如何使用 TypeScript 编译器的例子&lt;/a&gt;。（诚然，目前&lt;a href=&quot;http://angularjs.blogspot.com/2015/09/angular-2-survey-results.html&quot;&gt;并非所有人都在拥抱 TypeScript&lt;/a&gt;，但我有理由相信等到正式发布之后，TypeScript 会成为事实上的标准）。这种一致性应该会帮助初学者避免在学习 React 时遇到的疑惑和选择困难。&lt;/p&gt;

&lt;h4 id=&quot;极少的代码变动&quot;&gt;极少的代码变动&lt;/h4&gt;

&lt;p&gt;2015 年是 &lt;a href=&quot;https://medium.com/@ericclemmons/javascript-fatigue-48d4011b6fc4#.559iqxb39&quot;&gt;JavaScript 疲劳&lt;/a&gt;元年，React 可以说是罪魁祸首。而且 React 尚未发布 1.0，所以未来还可能有很多变数。React 生态圈依旧在快速地变动着，尤其是&lt;a href=&quot;https://github.com/kriasoft/react-starter-kit/issues/22&quot;&gt;各种 Flux 变种&lt;/a&gt;和&lt;a href=&quot;https://github.com/rackt/react-router&quot;&gt;路由&lt;/a&gt;。也就是说，你今天用 React 写的所有东西，都有可能在 React 1.0 正式发布后过时，或者必须进行大量的改动。&lt;/p&gt;

&lt;p&gt;相反，Angular 2 是一个对已经成熟完整框架（Angular 1）的重新发明，而且经过仔细、系统的设计。所以 Angular 不大可能在正式发布后要求已有项目进行痛苦的代码变动。Angular 作为一个完整的框架，你在选择它的时候，也会信任其开发团队，相信他们会认真决定框架的未来。而使用 React，一切都需要你自己负责，你要自己整合一大堆开源类库来打造一个完整的应用，类库之间互不相干且变动频繁。这是一个令人沮丧的耗时工作，而且永远没有尽头。&lt;/p&gt;

&lt;h4 id=&quot;广泛的工具支持&quot;&gt;&lt;strong&gt;广泛的工具支持&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;后面我会说，我认为 React 的 JSX 是非常耀眼的亮点。然而要使用 JSX，你需要选择支持它的工具。尽管 React 已经足够流行，工具支持不再是什么问题，但诸如 IDE 和 lint 工具等新工具还不大可能很快得到支持。Angular 2 的模版是保存在一个字符串或独立的 HTML 文件中的，所以不要求特殊的工具支持（不过似乎 Angular 字符串模版的智能解析工具已经呼之欲出了）。&lt;/p&gt;

&lt;h4 id=&quot;web-components-友好&quot;&gt;Web Components 友好&lt;/h4&gt;

&lt;p&gt;Angular 2 还拥抱了 Web Component 标准。唉，真尴尬我居然一开始忘记提到这点了——最近我还发布了一门关于&lt;a href=&quot;https://www.pluralsight.com/courses/web-components-shadow-dom&quot;&gt;Web Components 课程&lt;/a&gt;呢！简单来说，把 Angular 2 组件转换成原生 Web Components 应该会比 React 组件容易得多。固然 Web Components 的&lt;a href=&quot;http://jonrimmer.github.io/are-we-componentized-yet/&quot;&gt;浏览器支持度依然很弱&lt;/a&gt;，但长期来看，对 Web Components 友好是很大的优势。&lt;/p&gt;

&lt;p&gt;Angular 的实现有其自身的局限和陷阱，这正好让我过渡到对 React 优势的讨论。&lt;/p&gt;

&lt;h3 id=&quot;react-的优点&quot;&gt;React 的优点&lt;/h3&gt;

&lt;p&gt;现在，让我们看看是什么让 React 如此与众不同。&lt;/p&gt;

&lt;h4 id=&quot;jsx&quot;&gt;&lt;strong&gt;JSX&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;JSX 是一种类似 HTML 的语法，但它实际上会被编译成 JavaScript。将标签与代码混写在同一个文件中意味着输入一个组件的函数或者变量时你将享受到自动补全的福利。而 Angular 基于字符串的模版就相形见绌了：很多编辑器都不会高亮它们（只会显示单色）、只有有限的代码补全支持，并且一直到运行时才会报错。并且，通常你也只能得到很有限的错误提示。不过，Angular 的团队&lt;a href=&quot;https://github.com/angular/angular/issues/4417&quot;&gt;造了一个自己的 HTML 解析器来解决这个问题&lt;/a&gt;。（叼叼叼！）&lt;/p&gt;

&lt;p&gt;如果你不喜欢 Angular 的字符串模版，你可以把模版移到一个单独的文件里去。不过这样你就回到了我认为的“老样子”：你需要在自己脑袋里记住这两个文件的关联，不但没有代码自动补全，也没有任何编译时检查来协助你。这听起来可能并不算什么……除非你已经爱上了与 React 相伴的日子。在同一个文件中组合组件还能享受编译时的检查，大概是 JSX 最与众不同的地方之一了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://p5.qhimg.com/d/inn/8a99f370/2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对比 Angular 2 与 React 在标签忘记闭合时是如何表现的。&lt;/p&gt;

&lt;p&gt;关于为什么 JSX 是一个巨大的优势，可以看看 &lt;a href=&quot;https://medium.com/@housecor/react-s-jsx-the-other-side-of-the-coin-2ace7ab62b98#.5007n49wq&quot;&gt;JSX：硬币的另一面（JSX: The Other Side of the Coin）&lt;/a&gt;. （P.S. 这是作者写的另一篇文章，如果大家希望我们可以把这篇也翻了，欢迎在评论区举手）&lt;/p&gt;

&lt;h4 id=&quot;react-报错清晰快速&quot;&gt;React 报错清晰快速&lt;/h4&gt;

&lt;p&gt;当你在 React 的 JSX 中不小心手抖打错时，它并不会被编译。这是一件非常美妙的事情：无论你是忘记闭合了标签还是引用了一个不存在的属性（property），你都可以立刻知道到底是哪一行出错了。&lt;strong&gt;JSX 编译器会指出你手抖的具体行号&lt;/strong&gt;，彻彻底底加速你的开发。&lt;/p&gt;

&lt;p&gt;相反，当你在 Angular 2 中不小心敲错了一个变量时，鸦雀无声。&lt;strong&gt;Angular 2 并不会在编译时做什么，它会等到运行时才静默报错。&lt;/strong&gt;它报错得&lt;em&gt;如此之慢&lt;/em&gt;，我加载完整个应用然后奇怪为什么我的数据没有显示出来呢？这太不爽了。&lt;/p&gt;

&lt;h4 id=&quot;react-以-javascript-为中心&quot;&gt;React 以 JavaScript 为中心&lt;/h4&gt;

&lt;p&gt;终于来了。这才是 React 和 Angular 的根本区别。&lt;strong&gt;很不幸，Angular 2 仍然是以 HTML 而非 JavaScript 为中心的。&lt;/strong&gt;Angular 2 并没有解决它设计上的根本问题：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Angular 2 继续把 “JS” 放到 HTML 里。React 则把 “HTML” 放到 JS 里。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这种分歧带来的影响真是再怎么强调也不为过。它们从根本上影响着开发体验。Angular 以 HTML 为中心的设计留下了巨大的缺陷。正如我在 &lt;a href=&quot;https://medium.com/@housecor/react-s-jsx-the-other-side-of-the-coin-2ace7ab62b98#.jqh5kkxlk&quot;&gt;JSX：硬币的另一面&lt;/a&gt; 中所说的，JavaScript 远比 HTML 要强大。因此，&lt;strong&gt;增强 JavaScript 让其支持标签要比增强 HTML 让其支持逻辑要合理得多&lt;/strong&gt;。无论如何，HTML 与 JavaScript 都需要某种方式以粘合在一起。React 以 JavaScript 为中心的思路从根本上优于 Angular、Ember、Knockout 这些以 HTML 为中心的思路。&lt;/p&gt;

&lt;p&gt;让我们来看看为什么。&lt;/p&gt;

&lt;h4 id=&quot;react-以-javascript-为中心的设计--简约&quot;&gt;React 以 JavaScript 为中心的设计 = 简约&lt;/h4&gt;

&lt;p&gt;Angular 2 延续了 Angular 1 试图让 HTML 更加强大的老路子。所以即使是像循环或者条件判断这样的简单任务你也不得不使用 Angular 2 的独特语法来完成。例如，Angular 2 通过两种语法同时提供了单向数据绑定与双向数据绑定，可不幸的是它们实在差得有点多：&lt;/p&gt;

&lt;div class=&quot;language-hbs highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;{{&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;myVar&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}}&lt;/span&gt;        //单向数据绑定
ngModel=&quot;myVar&quot;  //双向数据绑定
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在 React 中，数据绑定语法不取决于数据流的单双向（数据绑定的单双向是在其他地方处理的，不得不说我觉得理应如此）。不管是单向还是双向数据流，绑定语法都是这样的：&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;myVar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Angular 2 的内联母版（inline master templates）使用了这样的语法：&lt;/p&gt;

&lt;div class=&quot;language-hbs highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;ul&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;li&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ngFor=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;#hero of heroes&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;{{&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;hero&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}}&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/ul&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面这个代码片段遍历了一组 hero，而我比较关心的几点是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;通过星号来声明一个“母版”实在是太晦涩了&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;hero&lt;/code&gt; 前的英镑符号（&lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt;）用于声明一个局部模版变量。这个概念感觉非常鸡肋（如果你偏好不使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt;，你也可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;var-&lt;/code&gt; 前缀写法）&lt;/li&gt;
  &lt;li&gt;为 HTML 加入了循环语义的HTML 特性（attribute）&lt;code class=&quot;highlighter-rouge&quot;&gt;ngFor&lt;/code&gt; 是 Angular 特有的东西&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;相比上面 Angular 2 的语法，React 的语法可是纯净的 JavaScript （不过我得承认下面的属性 &lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt; 是个 React 的私货）&lt;/p&gt;

&lt;div class=&quot;language-hbs highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;ul&amp;gt;&lt;/span&gt;
  { heroes.map(hero =&amp;gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;li&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;key=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;{hero.id}&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;{hero.name}&lt;span class=&quot;nt&quot;&gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
  )}
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/ul&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;鉴于 JS 原生支持循环，React JSX 利用 JS 的力量来做到这类事情简直易如反掌，配合 &lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;filter&lt;/code&gt; 能做的还远不止此。&lt;/p&gt;

&lt;p&gt;去看看 &lt;a href=&quot;https://angular.io/docs/ts/latest/guide/cheatsheet.html&quot;&gt;Angular 2 速查表&lt;/a&gt;？那不是 HTML，也不是 JavaScript……这叫 &lt;strong&gt;Angular&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;读懂 Angular：&lt;/strong&gt; 学一大堆 Angular 特有的语法&lt;/p&gt;

  &lt;p&gt;读懂 React： 学 JavaScript&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;React 因为语法和概念的简约而与众不同。我们不妨品味下当今流行的 JS 框架/库都是如何实现遍历的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Ember     : 
Angular 1 : ng-repeat
Angular 2 : ngFor
Knockout  : data-bind=&quot;foreach&quot;
React     : 直接用 JS 就好啦 :)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;除了 React，所有其它框架都用自己的专有语法重新发明了一个我们在 JavaScript 常见得不能再常见的东西：&lt;strong&gt;循环&lt;/strong&gt;。这大概就是 React 的美妙之处，利用 JavaScript 的力量来处理标签，而不是什么奇怪的新语法。&lt;/p&gt;

&lt;p&gt;Angular 2 中的奇怪语法还有点击事件的绑定：&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;click&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;onSelect(hero)&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;相反，React 再一次使用了普通的 JavaScript：&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;onClick&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;onSelect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hero&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;并且，鉴于 React 内建了一个模拟的事件机制（Angular 2 也有），你并不需要去担心使用内联语法声明事件处理器所暗含的性能问题。&lt;/p&gt;

&lt;p&gt;为什么要强迫自己满脑子都是一个框架的特殊语法呢？为什么不直接拥抱 JS 的力量？&lt;/p&gt;

&lt;h4 id=&quot;奢华的开发体验&quot;&gt;奢华的开发体验&lt;/h4&gt;

&lt;p&gt;JSX 具备的代码自动补全、编译时检查与丰富的错误提示已经创造了非常棒的开发体验，既为我们减少了输入，与节约了时间。而配合上热替换（hot reloading）与时间旅行（time travel），你将获得前所未有的开发体验，效率高到飞起。&lt;/p&gt;

&lt;p&gt;原文这里链了个 Youtube 上的视频：&lt;a href=&quot;https://www.youtube.com/watch?v=xsSnOQynTHs&amp;amp;feature=youtu.be&quot;&gt;Dan Abramov - Live React: Hot Reloading with Time Travel at react-europe 2015&lt;/a&gt;，大家自备梯子。&lt;/p&gt;

&lt;h4 id=&quot;担心框架的大小&quot;&gt;担心框架的大小？&lt;/h4&gt;

&lt;p&gt;这里是一些常见框架/库压缩后的大小（&lt;a href=&quot;https://gist.github.com/Restuta/cda69e50a853aa64912d&quot;&gt;来源&lt;/a&gt;）：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Angular 2:&lt;/strong&gt; 566k (766k with RxJS)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Ember:&lt;/strong&gt; 435k&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://ajax.googleapis.com/ajax/libs/angularjs/1.4.8/angular.min.js&quot;&gt;&lt;strong&gt;Angular 1&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;:&lt;/strong&gt; 143k&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;React + Redux:&lt;/strong&gt; 139k&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;列出的都是框架级的、用于浏览器且压缩后的大小（但并未 gzip）。需要补充的是，Angular 2 的尺寸在最终版本发布时应该会有所减小。&lt;/p&gt;

&lt;p&gt;为了做一个更真实的对比，我将 Angular 2 &lt;a href=&quot;https://angular.io/docs/ts/latest/tutorial/&quot;&gt;官方教程&lt;/a&gt;中的 Tour of Heroes 应用用 Angular 2 和 React（还用上了新的 &lt;a href=&quot;https://github.com/coryhouse/react-slingshot&quot;&gt;React Slingshot&lt;/a&gt; 入门套件）都实现了一遍，结果如何呢？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/coryhouse/angular-2-tour-of-heroes/tree/master&quot;&gt;&lt;strong&gt;Angular 2&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;:&lt;/strong&gt; 764k 压缩后&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/coryhouse/react-tour-of-heroes&quot;&gt;&lt;strong&gt;React + Redux&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;:&lt;/strong&gt; 151k 压缩后&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以看到，&lt;strong&gt;做一个差不多的东西，Angular 2 目前的尺寸是 React + Redux 的五倍还多&lt;/strong&gt;。重要的事情再说一遍，Angular 2 的最终版本应该会减重。&lt;/p&gt;

&lt;p&gt;不过，我承认关于框架大小的担忧可能被夸大了：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;大型应用往往至少有几百 KB 的代码，经常还更多，不管它们是不是使用了框架。开发者需要做很多的抽象来构建一个复杂的软件。无论这些抽象是来自框架的还是自己手写的，它都会对应用的加载性能造成负面影响。&lt;/p&gt;

  &lt;p&gt;就算你完全杜绝框架的使用，许多应用仍然是几百 KB 的 JavaScript 在那。 — Tom Dale &lt;a href=&quot;http://tomdale.net/2015/11/javascript-frameworks-and-mobile-performance/&quot;&gt;JavaScript Frameworks and Mobile Performance&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Tom 的观点是对的。像 Angular、Ember 这样的框架之所以更大是因为它们自带了更多的功能。&lt;/p&gt;

&lt;p&gt;但是，我关心的点在于：很多应用其实用不到这种大型框架提供的所有功能。在这个越来越拥抱微服务、微应用、&lt;a href=&quot;http://www.npmjs.com&quot;&gt;单一职责模块（single-responsibility packages）&lt;/a&gt;的时代，&lt;strong&gt;React 通过让你自己挑选必要模块，让你的应用大小真正做到量身定做&lt;/strong&gt;。在这个有着 200,000 个 npm 模块的世界里，这点非常强大。&lt;/p&gt;

&lt;h4 id=&quot;react-信奉unix-哲学&quot;&gt;React 信奉&lt;a href=&quot;https://en.wikipedia.org/wiki/Unix_philosophy&quot;&gt;Unix 哲学&lt;/a&gt;.&lt;/h4&gt;

&lt;p&gt;React 是一个类库。它的哲学与 Angular、Ember 这些大而全的框架恰恰相反。你可以根据场景挑选各种时髦的类库，搭配出你的最佳组合。JavaScript 世界在飞速发展，React 允许你不断用更好的类库去迭代你应用中的每个小部分，而不是傻等着你选择的框架自己升级。&lt;/p&gt;

&lt;p&gt;Unix 久经沙场屹立不倒，原因就是：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;小而美、可组合、目的单一，这种哲学永远不会过时。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;React 作为一个专注、可组合并且目的单一的工具，已经被&lt;a href=&quot;https://github.com/facebook/react/wiki/Sites-Using-React&quot;&gt;全世界的各大网站们&lt;/a&gt;使用，预示着它的前途光明（当然，Angular 也被用于&lt;a href=&quot;https://www.madewithangular.com/#/&quot;&gt;许多大牌网站&lt;/a&gt;）。&lt;/p&gt;

&lt;h4 id=&quot;谢幕之战&quot;&gt;谢幕之战&lt;/h4&gt;

&lt;p&gt;Angular 2 相比第一代有着长足的进步。新的组件模型比第一代的指令（directives）易学许多；新增了对于同构／服务器端渲染的支持；使用虚拟 DOM 提供了 3-10 倍的性能提升。这些改进使得 Angular 2 与 React 旗鼓相当。不可否认，它功能齐全、观点鲜明，能够显著减少 “JavaScript 疲劳” 。&lt;/p&gt;

&lt;p&gt;不过，Angular 2 的大小和语法都让我望而却步。Angular 致力的 HTML 中心设计比 React 的 JavaScript 中心模型要复杂太多。在 React 中，你并不需要学习 &lt;code class=&quot;highlighter-rouge&quot;&gt;ng-什么什么&lt;/code&gt; 这种框架特有的 HTML 补丁（shim），你只要写 JavaScript 就好了。这才是我相信的未来。&lt;/p&gt;

&lt;h3 id=&quot;著作权声明&quot;&gt;著作权声明&lt;/h3&gt;

&lt;p&gt;本文译自 &lt;a href=&quot;https://medium.freecodecamp.com/angular-2-versus-react-there-will-be-blood-66595faafd51#.v4y4euy1r&quot;&gt;Angular 2 versus React: There Will Be Blood&lt;/a&gt;，其实&lt;a href=&quot;http://www.w3ctech.com/topic/1675?from=timeline&amp;amp;isappinstalled=0&quot;&gt;之前有人翻译过&lt;/a&gt;，但是翻得水平有一点不忍直视，我们不希望浪费这篇好文章。&lt;br /&gt;
本文由 &lt;a href=&quot;https://www.zhihu.com/people/li-ling-hao&quot;&gt;@李凌豪&lt;/a&gt; &lt;a href=&quot;https://www.zhihu.com/people/huxpro&quot;&gt;@黄玄&lt;/a&gt; 联合翻译，首次发布于&lt;a href=&quot;http://zhuanlan.zhihu.com/FrontendMagazine&quot;&gt;前端外刊评论 · 知乎专栏&lt;/a&gt;，转载请保留原文链接 ;)&lt;/p&gt;
</description>
        <pubDate>Mon, 01 Feb 2016 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2016/02/01/React-vs-Angular2/</link>
        <guid isPermaLink="true">http://localhost:4000/2016/02/01/React-vs-Angular2/</guid>
        
        <category>前端开发</category>
        
        <category>JavaScript</category>
        
        <category>译文</category>
        
        
      </item>
    
      <item>
        <title>都 2015 年了，CSS 怎么还是这么糟糕</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;下滑这里查看更多内容&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;watching-fullscreen-&quot;&gt;&lt;a href=&quot;https://huangxuan.me/css-sucks-2015/&quot;&gt;Watching Fullscreen →&lt;/a&gt;&lt;/h3&gt;

&lt;div class=&quot;visible-md visible-lg&quot;&gt;
&lt;img src=&quot;//huangxuan.me/css-sucks-2015/attach/qrcode.png&quot; width=&quot;350&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;你也可以通过扫描二维码在手机上观看&lt;/small&gt;
&lt;/div&gt;

&lt;p&gt;这个 Web Slides 开源在&lt;a href=&quot;https://github.com/Huxpro/css-sucks-2015&quot;&gt;我的 Github 上&lt;/a&gt;，欢迎你帮助我完善这个展示文稿，你可以给我提 issue，可以 fork &amp;amp; pull request。如果它能帮助到你了，希望你还能不吝啬 star 一下这个项目&lt;/p&gt;

&lt;h3 id=&quot;catalog&quot;&gt;Catalog&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Document Times
    &lt;ul&gt;
      &lt;li&gt;Frameworks&lt;/li&gt;
      &lt;li&gt;Style Guide
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;OOCSS&lt;/strong&gt;&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;SMACSS&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Pre-processer&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;PostCSS&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Application Times
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;Shadow DOM&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;CSS “4”&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;Naming Convention
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;BEM&lt;/strong&gt;&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;SUIT&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Atomic CSS&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;CSS in JS&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;CSS Modules&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;Interoperable CSS&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;PostCSS, again&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;My Opinionated Proposal
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;POCss&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;pocss-page-override-components-css&quot;&gt;POCss: Page Override Components CSS&lt;/h2&gt;

&lt;h3 id=&quot;1-scoping-components-css-blocks-should-only-be-used-inside-a-component-of-the-same-name&quot;&gt;1. Scoping Components &lt;br /&gt;&lt;small style=&quot;line-height:2em;&quot;&gt;&lt;em&gt;CSS Blocks should only be used inside a component of the same name.&lt;/em&gt;&lt;/small&gt;&lt;/h3&gt;

&lt;div class=&quot;language-scss highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Component/index.scss
&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;.ComponentName&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;--mofierName&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;__decendentName&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;--modifierName&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;.isStateOfComponent&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Component/index.js&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'./index.scss'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;CSS is &lt;em&gt;always bundled&lt;/em&gt; with components&lt;br /&gt;(from loading, mount to unmount)&lt;/p&gt;

&lt;h3 id=&quot;2-components-can-be-overrode-by-pages-there-is-always-requirements-to-rewrite-styles-of-components-in-pages&quot;&gt;2. Components can be Overrode by Pages &lt;br /&gt;&lt;small style=&quot;line-height:2em;&quot;&gt;&lt;em&gt;There is always requirements to rewrite styles of components in pages&lt;/em&gt;&lt;/small&gt;&lt;/h3&gt;

&lt;div class=&quot;language-scss highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Pages/PageA.scss
&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;#PageA&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;.pagelet-name&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;.pagelet-descendent-name&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;.ComponentName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* override */&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Pages/index.js&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'./PageA.scss'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;#Page&lt;/em&gt; for absolutely scoping between pages&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;.pagelet-name&lt;/em&gt; should be lowercase to prevent conflicting with components&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;why-poc&quot;&gt;Why POC?&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;It’s technology-agnostic&lt;/strong&gt;
&lt;small&gt;
  &lt;em&gt;One css framework can be played with whatever technology stacks&lt;/em&gt;&lt;br /&gt;
  &lt;em&gt;You can combined Scss, PostCSS and whatever you want&lt;/em&gt;
&lt;/small&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Solving problems, and easy&lt;/strong&gt;
&lt;small&gt;
  &lt;em&gt;Makes reading and teamwork much easier&lt;/em&gt;&lt;br /&gt;
  &lt;em&gt;Get all benefit from BEM, SUITCSS and others&lt;/em&gt;
&lt;/small&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Leverage the power of cascading properly&lt;/strong&gt;
&lt;small&gt;
  &lt;em&gt;Scoping components but allow reasonable overriding&lt;/em&gt;&lt;br /&gt;
  &lt;em&gt;It’s pragmatic, flexible and hitting the sweet spot&lt;/em&gt;
&lt;/small&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;thanks&quot;&gt;Thanks&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://lab.hakim.se/reveal-js&quot;&gt;Reveal.js&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 28 Dec 2015 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2015/12/28/css-sucks-2015/</link>
        <guid isPermaLink="true">http://localhost:4000/2015/12/28/css-sucks-2015/</guid>
        
        <category>前端开发</category>
        
        <category>CSS</category>
        
        
      </item>
    
      <item>
        <title>iOS 9，为前端世界都带来了些什么？「译」</title>
        <description>&lt;p&gt;2015 年 9 月，Apple 重磅发布了全新的 iPhone 6s/6s Plus、iPad Pro 与全新的操作系统 watchOS 2 与 tvOS 9（是的，这货居然是第 9 版），加上已经发布的 iOS 9，它们都为前端世界带来了哪些变化呢？作为一个 web 开发者，是时候站在我们的角度来说一说了！&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;注！&lt;/strong&gt; 该译文存在大量英文术语，笔者将默认读者知晓 ES6、viewport、native app、webview 等常用前端术语，并不对这些已知术语进行汉语翻译
对于新发布或较新的产品名称与技术术语，诸如 Apple Pen、Split View 等专有名词，笔者将在文中使用其英文名，但会尝试对部分名词进行汉语标注
另外，出于对 wiki 式阅读的偏爱，笔者为您添加了很多额外的链接，方便您查阅文档或出处&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;简而言之&quot;&gt;简而言之&lt;/h3&gt;

&lt;p&gt;如果你不想阅读整篇文章，这里为你准备了一个总结：&lt;/p&gt;

&lt;h6 id=&quot;新的设备特性&quot;&gt;新的设备特性&lt;/h6&gt;

&lt;ul&gt;
  &lt;li&gt;iPhone 6s 与 6s Plus 拥有 &lt;strong&gt;“&lt;a href=&quot;http://www.apple.com/iphone-6s/3d-touch/&quot;&gt;3D Touch&lt;/a&gt;”&lt;/strong&gt;，这是一个全新的硬件特性，它可以侦测压力，是一个可以让你拿到手指压力数据的 API&lt;/li&gt;
  &lt;li&gt;iPad Pro 的 viewport 为 1024px，与以往的 iPad 全都不同&lt;/li&gt;
  &lt;li&gt;想在 iPad Pro 上支持新的 Apple Pen？不好意思，目前似乎并没有适用于网站的 API&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;新的操作系统特性与-web-相关的&quot;&gt;新的操作系统特性（与 web 相关的）&lt;/h6&gt;

&lt;ul&gt;
  &lt;li&gt;iPad 上的 Safari 现在可以通过 &lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/WindowsViews/Conceptual/AdoptingMultitaskingOniPad/QuickStartForSlideOverAndSplitView.html#//apple_ref/doc/uid/TP40015145-CH13-SW1&quot;&gt;Split View&lt;/a&gt;（分屏视图）与其他应用一起使用，这意味着新的 viewport 尺寸将会越来越常见&lt;/li&gt;
  &lt;li&gt;新的 Safari View Controller（&lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/SafariServices/Reference/SFSafariViewController_Ref/index.html#//apple_ref/occ/cl/SFSafariViewController&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SFSafariViewController&lt;/code&gt;&lt;/a&gt;）可以让你在 native app 内提供与 Safari 界面、行为连贯一致的应用内网页浏览体验&lt;/li&gt;
  &lt;li&gt;注意啦！Safari 新加入了 Content Blocker（内容拦截器）。以后，并不是所有的访问都一定会出现在你的 Google Analytics 了&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/AppSearch/UniversalLinks.html#//apple_ref/doc/uid/TP40016308-CH12&quot;&gt;Universal Links&lt;/a&gt; 可以让应用的拥有者在 iOS 内部“占有”自己的域名。因此，访问 yourdomain.com 将会打开你的应用（类似 Android 的 Intents 机制）&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/AppSearch/index.html#//apple_ref/doc/uid/TP40016308&quot;&gt;App Search（应用搜索）&lt;/a&gt;：现在，Apple 将会抓取你的网页内容（与 native app 内容）用于 Spotlight 与 Siri 的搜索结果，&lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/AppSearch/WebContent.html#//apple_ref/doc/uid/TP40016308-CH8&quot;&gt;想知道你的标签都兼容吗？&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;你的网站现在可以通过 JavaScript API 访问 iCloud 的用户数据&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;新的-api-支持&quot;&gt;新的 API 支持&lt;/h6&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Performance/timing&quot;&gt;Performance Timing API&lt;/a&gt; 在 iOS 9 得到回归&lt;/li&gt;
  &lt;li&gt;关于 HTML5 Video，你现在可以在支持 &lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/WindowsViews/Conceptual/AdoptingMultitaskingOniPad/QuickStartForPictureInPicture.html#//apple_ref/doc/uid/TP40015145-CH14&quot;&gt;Picture in Picture（画中画）&lt;/a&gt;的 iPad 设备上提供这项新功能；你的视频甚至可以在 Safari 关闭后继续播放&lt;/li&gt;
  &lt;li&gt;更好的 ES6 支持：classes（类）, computed properties（可计算属性）, template literals（模版字符串）等&lt;/li&gt;
  &lt;li&gt;Backdrop CSS filters（背景滤镜）&lt;/li&gt;
  &lt;li&gt;CSS @supports 与 CSS Supports JavaScript API&lt;/li&gt;
  &lt;li&gt;CSS Level4 伪选择器&lt;/li&gt;
  &lt;li&gt;用于支持分页内容的 CSS Scroll Snapping&lt;/li&gt;
  &lt;li&gt;WKWebView 现在可以访问本地文件了&lt;/li&gt;
  &lt;li&gt;我们仍然需要等待 Push Notification，camera access，Service Workers 这些现代 web API 的到来&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;新的操作系统&quot;&gt;新的操作系统&lt;/h6&gt;

&lt;ul&gt;
  &lt;li&gt;新一代 Apple TV 的 &lt;strong&gt;tvOS&lt;/strong&gt;： 没有浏览器，也没有 webview。但是 JavaScript、XHR 和 DOM 可以通过一个叫做 TVML 的标记语言来使用&lt;/li&gt;
  &lt;li&gt;Apple Watch 的 &lt;strong&gt;watchOS&lt;/strong&gt;：完全没有任何浏览器和 webview&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;再注！&lt;/strong&gt; 由于原文写于 Apple 发布会之前，为了不让读者感到奇怪，笔者将会对文章进行适当改写与补充，以保证本文的连贯性&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;新的-ios-设备特性&quot;&gt;新的 iOS 设备特性&lt;/h3&gt;

&lt;h5 id=&quot;iphones-6s-与-3d-touch&quot;&gt;iPhones 6s 与 3D Touch&lt;/h5&gt;

&lt;p&gt;从 web 设计与开发的角度来说，新的 iPhone 6s 与 6s Plus 与之前的版本并没有太多差别。不过，有一个特性注定会吸引我们的目光：&lt;strong&gt;3D Touch&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们无法确定 Apple 是不是只是重命名了一下 “Force Touch”（用于 Apple Watch、TrackPad 2 与最新的 MacBook 上）或者 3D Touch 的确是一个为 iPhone 定制的似曾相识却不同的东西。3D Touch 允许操作系统和应用侦测每一个手指与屏幕接触时的压力。从用户体验的角度来说，最大的变化莫过于当你用点力去触碰或者拖拽屏幕时，操作系统将会触发诸如 peek，pop 这些新机制。那么问题来了：&lt;strong&gt;我们是否能够在网站中使用这个新玩意呢？让我们一点点来看：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;iOS 9 搭载的 Safari 包含了一些用于 “Force Touch” 的新 API，但它们其实并不是那个用于 iPhone 6s 3D Touch 的 API。你可以理解为这些 API 就是 MacBook 版 Safari 里为 Force Touch 准备的那些 API ，因为共享一套 codebase，所以它理所当然得存在了 iOS 版里而已。&lt;/p&gt;

&lt;p&gt;Force Touch API 为我们添加了两个新东西：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;你的 click 事件处理函数将会从 MouseEvent 中收到一个新的属性：&lt;code class=&quot;highlighter-rouge&quot;&gt;webkitForce&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;DOM 也新增了四个事件：&lt;code class=&quot;highlighter-rouge&quot;&gt;(webkit)mouseforcewillbegin&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;mouseforcedown&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;mouseforceup&lt;/code&gt; 与 &lt;code class=&quot;highlighter-rouge&quot;&gt;mouseforcechange&lt;/code&gt;。下边的示意图将告诉你这些事件是在何时被触发的：&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;http://www.mobilexweb.com/wp-content/uploads/2015/09/foceevents.png&quot; alt=&quot;Force Events&quot; /&gt;&lt;/p&gt;

&lt;p&gt;相信你已经从它们的名字中意识到了，这些事件都是基于鼠标而非触摸的，毕竟它们是为 MacBook 设计的。并且，TouchEvent 也并没有包含 &lt;code class=&quot;highlighter-rouge&quot;&gt;webkitForce&lt;/code&gt; 这个属性，它仅仅存在于 MouseEvent 里。在 iOS Safari 里，你确实可以找到 &lt;code class=&quot;highlighter-rouge&quot;&gt;onwebkitmouseforce&lt;/code&gt; 这一系列事件处理器，但是很可惜它们并不会被触发，click 返回的 MouseEvent 也永远只能得到一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;webkitForce: 0&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;可喜可贺的是，故事还没有结束。&lt;a href=&quot;https://w3c.github.io/touch-events/&quot;&gt;Touch Events v2 draft spec（触摸事件第二版草案）&lt;/a&gt; 中正式添加了 &lt;code class=&quot;highlighter-rouge&quot;&gt;force&lt;/code&gt; 属性。3D Touch 也得以在 iPhone 6s 与 6s+ 中通过 TouchEvent 访问到。不过，笔者也要在这里提醒大家，由于没有 &lt;code class=&quot;highlighter-rouge&quot;&gt;webkitmouseforcechange&lt;/code&gt; 这样给力的事件，在手机上我们只能通过 &lt;strong&gt;轮询 TouchEvent 的做法&lt;/strong&gt; 来不断检测压力值的改变……非常坑爹&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://twitter.com/fr3ino&quot;&gt;@Marcel Freinbichler&lt;/a&gt; 第一个在 Twitter 上晒出了自己的 &lt;a href=&quot;http://freinbichler.me/apps/3dtouch&quot;&gt;Demo&lt;/a&gt;。在 6s 或 new Macbook 的 Safari（目前仅 Safari 支持）上访问就可以看到圆圈会随着压力放大。墙内的小伙伴可以直接试试下面这个圆圈，体验下 3D/Force Touch 带来的的奇妙体验。&lt;/p&gt;

&lt;iframe src=&quot;//huangxuan.me/forcify/&quot; style=&quot;
    width:100%;
    height:500px;
    border: 0;
&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;如果你不巧在用不支持 3D/Force Touch 的设备，发现尼玛用力按下去之后居然圆圈也有反映！？&lt;/p&gt;

&lt;p&gt;放心，这真的不是你的设备突然习得了“感应压力”这项技能，而是因为 &lt;a href=&quot;http://huangxuan.me/forcify&quot;&gt;Forcify&lt;/a&gt; 是一个用于在所有设备上 polyfill 3D/Force Touch API 的 JS 库……它不但封装了 OSX/iOS 两个平台之间 API 的差异，还使用”长按”来模拟了 &lt;code class=&quot;highlighter-rouge&quot;&gt;force&lt;/code&gt; 值的变化……&lt;/p&gt;

&lt;h5 id=&quot;ipad-pro&quot;&gt;iPad Pro&lt;/h5&gt;

&lt;p&gt;全新的 iPad Pro（12.9 寸）打破了以往 iPad 渲染网站的方式。在此之前，市面上所有的 iPad（从初代 iPad，到 iPad Air 4，到 iPad Mini）都是以 768px 的宽度提供 viewport。&lt;/p&gt;

&lt;p&gt;而屏幕更大的 iPad Pro 选择了宽 1024px 的 viewport，这使得它天生就能容纳更多的内容。不少人说iPad Pro 就是抄 Microsft Surface Pro 的嘛……嗯哼，IE/Edge 在 Surface Pro 上就是以 1024px 作为视口宽度的……&lt;/p&gt;

&lt;p&gt;从交互的角度上来说，iPad Pro 虽然不支持 3D Touch，但是可以搭配 Smart Keyboard 与/或 Apple Pen（带有压力侦测）使用。对于键盘其实并没有什么好说的，如果一个网站在搭配键盘的桌面电脑上好用，它在 iPad Pro 上应该也不赖。而对于 Apple Pen，很可惜，目前似乎并没有 API 能让你在网站上获得这根笔的压力与角度。&lt;/p&gt;

&lt;h3 id=&quot;新的-ios-操作系统特性&quot;&gt;新的 iOS 操作系统特性&lt;/h3&gt;

&lt;h5 id=&quot;ipad-上的多任务处理&quot;&gt;iPad 上的多任务处理&lt;/h5&gt;

&lt;p&gt;自 iOS 9 起，iPad 允许两个应用在同一时刻并肩执行，有三种方式：&lt;strong&gt;Slide Over&lt;/strong&gt;，&lt;strong&gt;Split View&lt;/strong&gt; 与 &lt;strong&gt;Picture-in-Picture&lt;/strong&gt;。不过，每一种方式都有其硬件需求，比如说 Slide Over 需要 iPad Air, iPad Mini 2 以上的设备，而 Split View 由于对内存的要求目前只支持 iPad Air 2 与 iPad Pro。&lt;/p&gt;

&lt;h6 id=&quot;slide-over滑过来&quot;&gt;Slide Over（滑过来！）&lt;/h6&gt;

&lt;p&gt;Slide Over 支持的 App 并不多，不过 Safari 名列其中，这意味着我们的网站将可能在这个模式下被渲染。当网站处于 Slide Over 模式下时，它将在屏幕的右 1/4 位置渲染，并且置于其他 native app 之上。&lt;/p&gt;

&lt;p&gt;这个模式也为 Responsive Web Design（响应式网站设计）提出了新的挑战：&lt;strong&gt;一个只为 iPad 优化的网站，也需要能在该设备上以无需手动刷新的形式支持小屏幕的渲染。&lt;/strong&gt;因此，如果你正在使用服务器端探测（RESS），那么你的 iPad 版本需要以某种方式包含手机版本的网站，或者在进入该模式后重新加载一次。（如果你不了解 RESS，你可以观看我的&lt;a href=&quot;/2014/11/20/responsive-web-design/&quot;&gt;另一篇博文&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.mobilexweb.com/wp-content/uploads/2015/09/slideover.png&quot; alt=&quot;Slide Over&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在这个模式下，无论横屏还是竖屏，所有的 iPad（包括 Pro）都会把你的网站以 320px 的 viewport 宽度进行渲染，就好像在一个大 iPhone 5 上一样。你可以在 CSS 中通过 media query（媒体查询）探测到这个模式：&lt;/p&gt;

&lt;div class=&quot;language-css highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;/* iPad Air or iPad Mini */&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;device-width&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;768px&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;320px&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;/* iPad Pro */&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;device-width&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;1024px&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;320px&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h6 id=&quot;split-view分屏视图&quot;&gt;Split View（分屏视图）&lt;/h6&gt;

&lt;p&gt;在较新版本的 iPad 上，你可以将 Slide Over 的 Side View（侧视图）升级为 Split View。此时，两个应用将以相同比例在你的屏幕上同时工作。&lt;/p&gt;

&lt;p&gt;在这个模式下，我们的网站将可能……&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;以屏幕 1/3 比例渲染时&lt;/strong&gt;，viewport 在 iPad Air/mini 犹如 iPhone 5，宽 320px。而在 iPad Pro 上则像是 iPhone 6：宽 375px&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;以屏幕 1/2 比例渲染时&lt;/strong&gt;，viewport 在 iPad Air/mini 上呈现为 507px 宽，而在 iPad Pro（横屏）下呈现为 678px 宽&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;以屏幕 2/3 比例渲染时&lt;/strong&gt;，viewport 在 iPad Air/mini 上呈现为 694px 宽，而在 iPad Pro（横屏）下呈现为 981px 宽&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://www.mobilexweb.com/wp-content/uploads/2015/09/splitview.png&quot; alt=&quot;Split View&quot; /&gt;&lt;/p&gt;

&lt;h6 id=&quot;picture-in-picture画中画&quot;&gt;Picture in Picture（画中画）&lt;/h6&gt;

&lt;p&gt;在一些较新版本的 iPad 上，使用 HTML5 video 标签的网站可以将其暴露到 Picture in Picture 机制中。通过 API（本文稍后会讲）或用户的触发，视频可以独立于网站在其他应用的上方继续播放。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.mobilexweb.com/wp-content/uploads/2015/09/pip.png&quot; alt=&quot;Picture in Picture&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;ios-9-下的响应式网页设计&quot;&gt;iOS 9 下的响应式网页设计&lt;/h5&gt;

&lt;p&gt;下图向你展示了 iOS 9 所有可能的 viewport 尺寸，检查检查你的响应式断点都包含它们了吗？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.mobilexweb.com/wp-content/uploads/2015/09/ios9rwd.png&quot; alt=&quot;iOS 9 RWD&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;safari-view-controller&quot;&gt;Safari View Controller&lt;/h5&gt;

&lt;p&gt;如果你用过 Twitter 或者 Facebook（或者微信，微博……），那么你一定知道很多 native app 在打开一个网页链接时并不会默认使用 Safari。它们试图让你留在它们的应用里，所以通过提供 webview 让你在应用内进行网页浏览。可是问题在于，这类 webview 并不会与浏览器共享 cookies，sessions，autofill（自动填充）与 bookmark（书签），为了解决这些问题，就有了 Safari View Controller。&lt;/p&gt;

&lt;p&gt;现在，native app 可以使用 Safari View Controller 来打开网站，它提供与 Safari 完全一致的隐私政策、local storage，cookies、sessions 同时让用户留在你的 app 中，它通过一个 “Done”（完成）按钮使用户可以回到 native app 的上一个 controller。这个全新的 controller 还可以让我们在 Share（分享）按钮上添加自定义的操作，这些操作在用户使用 Safari 应用时并不会出现。同时，native app 对这个自定义 Safari 实例具有完全的内容控制，你可以屏蔽不想被渲染的内容。&lt;/p&gt;

&lt;p&gt;当你需要基于 web 的鉴权，比如 OAuth 时，使用 Safari View Controller 同样是一个好主意，这样就不再需要打开浏览器再重定向回你的应用。不过注意了，Safari View Controller 只适用于在线、公开的 web 内容。如果你的 web 内容假设在本地或者私服，那么 WKWebView 仍然是最推荐的选择。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;笔者八卦一下，Safari View Controller 实际上也算是半个社区推进的产物。早在 2014 年 12 月，Tumblr 的 iOS 工程师 Bryan 就发表了一篇著名的 &lt;a href=&quot;http://bryan.io/post/104845880796/we-need-a-safari-view-controller&quot;&gt;We need a “Safari view controller”&lt;/a&gt; 叙述现有 webview 在第三方登录鉴权时的窘境。
2015 年 6 月，Apple Safari 工程师 Ricky Mondello 的 Twitter 宣告了这个设想的落地：You all asked for it. Come see me introduce it. Introducing Safari View Controller 1:30 PM, Tuesday. Nob Hill.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;safari-content-blockers&quot;&gt;Safari Content Blockers&lt;/h5&gt;

&lt;p&gt;现在，iOS 9 上的 Safari 支持一种全新的 App Extensions（应用拓展）：&lt;strong&gt;Content Blocker&lt;/strong&gt;（内容拦截器）。这类拓展以 native app 的形式存在，你可以在 App Store 上下载到，它们可以拦截 Safari 内的任何内容，包括：跟踪器、广告、自定义字体、大图片、JavaScript 文件等等。&lt;/p&gt;

&lt;p&gt;作为 web 开发者，尽管我们不能禁用 Content Blocker，我们仍然应该注意到它们的存在。诸如 Crystal 的一些拦截器宣称他们&lt;a href=&quot;http://murphyapps.co/blog/2015/8/22/crystal-benchmarks&quot;&gt;可以提高网页的打开速度&lt;/a&gt;。Crystal 声称可以加快网页的加载速度 3.9 倍并且少用 53% 的带宽。不过问题是：到底哪些东西被拦截器拦截了？&lt;a href=&quot;http://thenextweb.com/apple/2015/08/27/content-blocking-in-ios-9-is-going-to-screw-up-way-more-than-just-ads/&quot;&gt;这篇文章&lt;/a&gt;提到了一些我们未来可能会遇到的问题。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.mobilexweb.com/wp-content/uploads/2015/09/crystal.png&quot; alt=&quot;crystal&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在 iOS 9 发布后，Peace，一个 Content Blocker，曾在 App Store 排名跻身前十。从用户的角度来说，如果一个网站由于被 Content Blocker 拦截了某些重要资源而不能正常工作，你可以长按重新加载按钮并且以不启用 Content Blocker 的方式重新加载这个网站（见下图，来自 MacWorld.com）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.mobilexweb.com/wp-content/uploads/2015/09/macworld.png&quot; alt=&quot;disable content blocker&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Content Blocker 能隐藏元素，也有能力通过 CSS 选择器、域名、类型、或者 URL 来过滤并拦截某个文件的加载，&lt;a href=&quot;https://itunes.apple.com/us/app/purify-blocker-fast-clutter/id1030156203?ls=1&amp;amp;mt=8&quot;&gt;Purify Blocker&lt;/a&gt; 给用户提供了拦截某一种内容类型的进阶选项，比如 Web Fonts。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.mobilexweb.com/wp-content/uploads/2015/09/purify.png&quot; alt=&quot;purify&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;wkwebview-的增强&quot;&gt;WKWebView 的增强&lt;/h5&gt;

&lt;p&gt;UIWebView 已经被官方弃用，虽然它还在在那，不过它再也不会得到什么升级。与此相反，WKWebView 正在取代它的位置。一个最受期待的特性现在终于推出：加载本地文件到 WKWebView。因此，现在 Apache Cordova 应用与其他 web 内容都可以直接从 iOS 包中使用本地文件了，不再需要各种诡异的 hack 了。&lt;/p&gt;

&lt;p&gt;此外，还有一些新特性也一并推出。比如说，通过 WKWebsiteDataStore，Objective-C 或 Swift 有能力查询与管理 webview 的本地存储（比如 localStorage 或 IndexedDB）。这就允许我们将原有的数据存储替换成新的某些东西，比如说替换成一个不永久的（Chrome for iOS 的隐身模式就需要这种东西）&lt;/p&gt;

&lt;h5 id=&quot;universal-links通用链接&quot;&gt;Universal Links（通用链接）&lt;/h5&gt;

&lt;p&gt;如果你既有一个网站，又有一个 native app，你现在可以通过 Universal Links 来增强用户体验。它允许你在操作系统内“占有”自己的域名，这样，一切指向你网站的链接都会被重定向到你的 app。&lt;/p&gt;

&lt;p&gt;目前，所有的 app 都是通过自定义 URI 来达到这个效果的，比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;comgooglemaps://&lt;/code&gt; 就可以用来从网站或者其他原生 iOS 应用中打开 Google Maps。&lt;/p&gt;

&lt;p&gt;想要提供这个特性的话，你首先需要在 native app 中实现 Deep Linking（深度链接），让应用中的内容与 Safari 的 URL 吻合。然后，你需要在 Apple 的网站上关联你的域名，取得这个域名的 SSL 认证并且把签名后的 JSON 部署到该域名上。这是为了防止第三方的应用“占据”了属于你而不属于他们的域名，比如说 twitter.com 被非 Twitter 的其他应用占据掉。&lt;/p&gt;

&lt;p&gt;目前唯一的缺点是用户好像并不能决定到底以哪种方式来打开内容（使用 web 还是 app），不过我们可以观望一段时间看看它会如何发展。在不远的这段时间里，你可能会发现在网站或 Google 搜索里点击一个链接时会没有任何预警的就跳进了 native app 里。&lt;/p&gt;

&lt;h5 id=&quot;app-search应用搜索&quot;&gt;App Search（应用搜索）&lt;/h5&gt;

&lt;p&gt;Apple 带着自己的 web 蜘蛛杀进了搜索的市场，而我们需要支持它得以在 Siri 与 Spotlight 中提升自己的曝光率。这在我们同时拥有网站与 app 时尤为重要，因为现在 Apple 会索引你网站的内容，但打开时却可能将用户带到了 app 里去。&lt;/p&gt;

&lt;p&gt;尽管这会开启 SEO 的新篇章，不过却相当容易。你需要使用一些标签标准，诸如 &lt;a href=&quot;http://schema.org/&quot;&gt;Web Schema&lt;/a&gt;、&lt;a href=&quot;http://applinks.org&quot;&gt;AppLinks&lt;/a&gt;、&lt;a href=&quot;http://ogp.me&quot;&gt;OpenGraph&lt;/a&gt; 或者 &lt;a href=&quot;https://dev.twitter.com/cards/mobile&quot;&gt;Twitter Cards&lt;/a&gt;，配合上 App Banner 与 &lt;code class=&quot;highlighter-rouge&quot;&gt;app-argument&lt;/code&gt;，如果你有你自己的 native app 的话。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;关于“让你的网页支持 Apple 搜索”的更多详情，请查阅 Apple 官方文档 &lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/AppSearch/WebContent.html#//apple_ref/doc/uid/TP40016308-CH8-SW5&quot;&gt;Mark Up Web Content&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Apple 刚刚发布了一个 &lt;a href=&quot;https://search.developer.apple.com/appsearch-validation-tool/&quot;&gt;App Search Validation Tool（应用搜索验证工具）&lt;/a&gt;来帮助你搞清楚，需要向你的网站添加什么才能支持 App Search&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.mobilexweb.com/wp-content/uploads/2015/09/appsearch-1024x467.png&quot; alt=&quot;App Search&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;cloudkit-js&quot;&gt;CloudKit JS&lt;/h5&gt;

&lt;p&gt;如果你拥有一个 native app，你很可能会将用户数据保存在 iCloud 上。在过去，只有 iOS 与 Mac 应用被允许使用它。现在，通过 CloudKit JS，你的网站也可以连接上 iCloud 数据了。&lt;/p&gt;

&lt;h5 id=&quot;back-button&quot;&gt;Back Button&lt;/h5&gt;

&lt;p&gt;现在，当你链接到一个 native app 时（通过自定义 URI 或者 Universal Link），Safari 会询问用户是否想要使用 native app 打开这个链接（见下图）。如果用户同意了，这个应用将被打开，并且在左上角会有一个返回按钮可以返回 Safari ，返回到你的网站。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.mobilexweb.com/wp-content/uploads/2015/09/back.png&quot; alt=&quot;backbutton&quot; width=&quot;320&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;新的-api-支持-1&quot;&gt;新的 API 支持&lt;/h3&gt;

&lt;h5 id=&quot;navigation-timing-api&quot;&gt;Navigation Timing API&lt;/h5&gt;

&lt;p&gt;Navigation Timing API 在 iOS 9 迎来了回归。让我们回忆一下，这货添加于 8.0 却在一周后的 8.1 中去掉了。这对于 Web 性能是个好消息。通过这个 API，我们可以更精确的测量时间，还可以获得一系列有关加载过程的时间戳，它们对于追踪与在真实场景中做决策来改进用户体验都非常有用。&lt;/p&gt;

&lt;h5 id=&quot;picture-in-picture&quot;&gt;Picture in Picture&lt;/h5&gt;

&lt;p&gt;PiP API（被称为 Presentation Mode API）目前只支持 iOS，它允许我们手动让一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;video&amp;gt;&lt;/code&gt; 元素进入或离开 PiP 模式如果 &lt;code class=&quot;highlighter-rouge&quot;&gt;video.webkitSupportsPresentationMode&lt;/code&gt; 是支持的。&lt;/p&gt;

&lt;p&gt;举个例子，我们可以在内嵌模式与 PiP 模式中切换：&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;video&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;webkitSetPresentationMode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;video&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;webkitPresentationMode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;picture-in-picture&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;inline&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; 
    &lt;span class=&quot;s2&quot;&gt;&quot;picture-in-picture&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们还可以通过新的 &lt;code class=&quot;highlighter-rouge&quot;&gt;onwebkitpresentationmodechanged&lt;/code&gt; 事件来检测 Presentation Mode（展示模式）的变化。&lt;/p&gt;

&lt;h5 id=&quot;backdrop-css&quot;&gt;Backdrop CSS&lt;/h5&gt;

&lt;p&gt;iOS 7 与最近的 Mac OS 使用 Backdrop filter（背景滤镜）来模糊背景（指 native 开发），而在网站上实现这个却并不容易。&lt;/p&gt;

&lt;p&gt;iOS 9 上的 Safari 现在支持了来自 Filter Effect v2 spec（滤镜特效第二版规范）的 &lt;strong&gt;backdrop-filter&lt;/strong&gt;。比如说，我们可以使用一个半透明的背景并且对其背后的背景使用滤镜：&lt;/p&gt;

&lt;div class=&quot;language-css highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;header&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;nl&quot;&gt;background-color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rgba&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;255&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;255&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;255&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
   &lt;span class=&quot;nl&quot;&gt;-webkit-backdrop-filter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blur&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;5px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
   &lt;span class=&quot;py&quot;&gt;backdrop-filter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blur&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;5px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://www.mobilexweb.com/wp-content/uploads/2015/09/backdrop.png&quot; alt=&quot;backdrop&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;css-scroll-snapping&quot;&gt;CSS Scroll Snapping&lt;/h5&gt;

&lt;p&gt;在 web 上实现分页内容（比如相册跑马灯）总是非常麻烦，无论是使用 JavaScript 框架、touch 事件还是 hacking 滚动条等等。Apple 新添加了一个很赞的 CSS 特性叫做 CSS Scroll Snapping。这个特性新增了一系列的 CSS 属性让你定义规则或者不规则的 snap zone（停留区域），这样滚动的位置就会“啪”地一下停在这个区域，而非像以前一样可以停在任何地方。&lt;/p&gt;

&lt;p&gt;来看个例子：&lt;/p&gt;

&lt;div class=&quot;language-css highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nf&quot;&gt;#photo-gallery&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;100%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;overflow-x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;scroll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;-webkit-scroll-snap-points-x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;repeat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;100%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;-webkit-scroll-snap-type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mandatory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;想要看个跑起来后的例子？笔者为大家准备了 webkit 的官方 &lt;a href=&quot;http://www.webkit.org/demos/scroll-snap/&quot;&gt;demo&lt;/a&gt;，不过这个属性目前只支持 iOS 9 Safari 哦，并不支持 webview&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;css-supports&quot;&gt;CSS Supports&lt;/h5&gt;

&lt;p&gt;CSS Supports，包括 CSS &lt;code class=&quot;highlighter-rouge&quot;&gt;@supports&lt;/code&gt; 与来自 CSS Conditional Rules Module Level 3 spec 的 JavaScript CSS Supports API 都在 iOS 上迎来降临。现在，我们可以针对某个 CSS 属性的特定值的支持情况来编写代码：&lt;/p&gt;

&lt;div class=&quot;language-css highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@supports&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;-webkit-scroll-snap-type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mandatory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;/* we use it */&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;同样，使用 JavaScript：&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;CSS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;supports&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;-webkit-scroll-snap-type&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;mandatory&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;一些细微的改进&quot;&gt;一些细微的改进&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;ECMAScript 6 的更完善支持：classed、computed properties、template literial 与 week sets&lt;/li&gt;
  &lt;li&gt;新的 CSS Level4 伪类/元素选择器：&lt;code class=&quot;highlighter-rouge&quot;&gt;:not&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;:matches&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;:any-link&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;:placeholder-shown&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;:read-write&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;:read-only&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Native app 现在可以通过 extension 来向 Safari 的 Shared Links（分享链接）窗口上注入信息&lt;/li&gt;
  &lt;li&gt;大量无前缀 CSS 属性的支持（终于），比如 transition、animation、@keyframes、flex 与 columns&lt;/li&gt;
  &lt;li&gt;Mac OS El Capitán 上的 Safari 9 提供了一个全新设计的 Web Inspector（Web 检查器）。幸运的是，iOS 9 的远程调试完全兼容 Mac OS 上的 Safari 8，所以你倒是不用急着升级你的 Mac OS&lt;/li&gt;
  &lt;li&gt;iOS 9 通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;-apple-font&lt;/code&gt; 加入了一些 Dynamic Fonts（动态字体），并且它们现在应用的是 Apple 的新字体：San Francisco，笔者的博客就已经用上它啦&lt;/li&gt;
  &lt;li&gt;scrollingElement 现在可用了&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;input type=file&amp;gt;&lt;/code&gt; 现在允许你从 iCloud Drive 与已安装的第三方应用，比如 Google Drive 中选择文件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://www.mobilexweb.com/wp-content/uploads/2015/09/IMG_2017.png&quot; alt=&quot;input file&quot; width=&quot;320&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当你加载一个 HTTPS 协议的页面时，你不能混用 HTTP 与 HTTPS 的资源&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;bugs&quot;&gt;Bugs&lt;/h3&gt;

&lt;p&gt;Bug 通常都要在几周之后才会显露出来，我也会持续跟进并更新这篇文章。目前为止，我的发现如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对于 Home Screen webapps（添加至主屏的 web 应用），&lt;code class=&quot;highlighter-rouge&quot;&gt;apple-mobile-web-app-status-bar-style&lt;/code&gt; 这个 meta 标签不起作用了！所以你现在不能再像过去一样使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;black-translucent&lt;/code&gt; 让你的 webapp 渲染在状态栏的后面了。（iOS 9.2 fixed 了这个 bug）&lt;/li&gt;
  &lt;li&gt;Speech Synthesis API （语音综合 API）不再工作了&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;仍在等待&quot;&gt;仍在等待……&lt;/h3&gt;

&lt;p&gt;当 Mac 上的 Safari、桌面电脑与 Android 上的 Chrome 都已经为网站支持 Push Notification （通知推送）时，iOS 上的 Safari 仍然不支持这个特性。就 API 而言，我们仍然没有：WebRTC、getUserMedia、Service Worker、FileSystem API、Network Information API、Battery Status API、Vibration API 等等……你又在 iOS 上等待哪些特性呢？&lt;/p&gt;

&lt;h3 id=&quot;watchos-与-tvos&quot;&gt;watchOS 与 tvOS&lt;/h3&gt;

&lt;p&gt;新发布的 watchOS 2.0 与 tvOS 9.0 都是基于 iOS 的操作系统，它们针对特定的设备发行（Apple Watch 与新的 Apple TV）。从用户的角度来说，那里并没有浏览器了。从开发者的角度，那里也没有 Webview 了。&lt;/p&gt;

&lt;p&gt;尽管有不少人抱怨（大部分都是针对 webview 的缺失），我并不能确定这是不是个坏主意。我猜测 Apple 会尝试通过 Siri 来将 “web” 带给 TV、手表、甚至 CarPlay 的用户。所以，如果你遵循了上述的 “App Search” 的步骤，你的内容将可能通过 Siri 在这些设备上以 widget（小部件）或者快捷回复的形式变得可以访问。&lt;/p&gt;

&lt;p&gt;对于 Apple TV ，它支持使用 JavaScript、DOM API 与 XMLHttpRequest 来让我们构建某种类似 Client-Server webapp 的东西。没有 HTML 和 CSS，这是什么把戏？其实它支持的叫 TVML，是一种基于 XML、为那些可以被渲染在 TV 屏幕上的特定内容而优化后的标签。这些标签只可以在来自应用商店的 native app 中渲染，但是这些 TVML 是由服务器端来生成的。&lt;/p&gt;

&lt;h3 id=&quot;著作权声明&quot;&gt;著作权声明&lt;/h3&gt;

&lt;p&gt;本文译自 &lt;a href=&quot;http://www.mobilexweb.com/blog/ios9-safari-for-web-developers&quot;&gt;iOS 9, Safari and the Web: 3D Touch, new Responsive Web Design, Native integration and HTML5 APIs — Breaking the Mobile Web&lt;/a&gt; &lt;br /&gt;
译者 &lt;a href=&quot;http://weibo.com/huxpro&quot;&gt;黄玄&lt;/a&gt;，首次发布于 &lt;a href=&quot;http://huangxuan.me&quot;&gt;Hux Blog&lt;/a&gt;，转载请保留以上链接&lt;/p&gt;
</description>
        <pubDate>Tue, 15 Dec 2015 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2015/12/15/ios9-safari-web/</link>
        <guid isPermaLink="true">http://localhost:4000/2015/12/15/ios9-safari-web/</guid>
        
        <category>前端开发</category>
        
        <category>JavaScript</category>
        
        <category>iOS</category>
        
        <category>译文</category>
        
        
      </item>
    
      <item>
        <title>「知乎」设计师如何学习前端？</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;这篇文章转载自&lt;a href=&quot;https://www.zhihu.com/question/21921588/answer/69680480&quot;&gt;我在知乎上的回答&lt;/a&gt;，也被刊登于&lt;a href=&quot;http://www.uisdc.com/head-first-front-end&quot;&gt;优秀网页设计&lt;/a&gt;等多个网站上 ;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;笔者的经历在知乎就可以看到，大学专业是数字媒体艺术，大一实习过动效设计师，大二拿到了人生第一个大公司 offer 是阿里的交互设计，后来转岗到淘宝旅行的前端团队，现在在微信电影票做前端研发。
&lt;br /&gt;
&lt;br /&gt;也是走过了不少野路子，不过还好有小右哥 &lt;a data-hash=&quot;cfdec6226ece879d2571fbc274372e9f&quot; href=&quot;//www.zhihu.com/people/cfdec6226ece879d2571fbc274372e9f&quot; class=&quot;member_mention&quot; data-editable=&quot;true&quot; data-title=&quot;@尤雨溪&quot; data-tip=&quot;p$b$cfdec6226ece879d2571fbc274372e9f&quot;&gt;@尤雨溪&lt;/a&gt; 这样艺术/设计转前端的大神在前面做典范，也证明这条路是玩的通的 ;)
&lt;br /&gt;
&lt;br /&gt;接下来就说说自己的学习建议吧，一个小教程，也是自己走过的流程，仅供参考哈
&lt;br /&gt;
&lt;br /&gt;————
&lt;br /&gt;
&lt;br /&gt;&lt;b&gt;背景篇&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;在这个时代学习新东西，一定要善于使用 Bing/Google 等搜索引擎…网络上的资源非常丰富，自学能力也尤为重要，尤其是对于学习技术！
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;b&gt;入门篇（HTML/CSS）&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;说起设计师希望学前端的初衷，大概还是因为各种华丽的网页特效/交互太过吸引人，这种感觉大概就是：“Hey，我的设计可以做成网页访问了呢！”
&lt;br /&gt;好在，“展示”对于前端技术来说反而是最简单的部分。所以，放下你对“编程”两个字的恐惧，&lt;b&gt;从“称不上是编程语言”的 HTML/CSS 开始，先做点有成就感的东西出来吧！&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;对于设计师来说，最有成就感的一定是“可以看到的东西”，而 HTML/CSS 正是用来干这个的，HTML 就是一堆非常简单的标签，而 CSS 无非就是把你画画的流程用&lt;b&gt;英语&lt;/b&gt;按一定的格式写出来而已：
&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt; p is paragraph! &lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;style&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;red&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;是不是非常容易，就跟读英语一样！
&lt;br /&gt;接下来，你就需要开始自学啦，比如常用 HTML 标签的意思，各种 CSS 的属性，还有 CSS 的盒模型、优先级、选择器……放心，它们都很容易；能玩得转 PS/AI/Flash/Axure/AE/Sketch 的设计师们，学这个洒洒水啦
&lt;br /&gt;
&lt;br /&gt;推荐几个资源：
&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;//link.zhihu.com/?target=http%3A//www.w3school.com.cn/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;w3school 在线教程&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt; (中文，一个很 Low 但是又很好的入门学习网站）
        &lt;br /&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;//link.zhihu.com/?target=http%3A//www.codecademy.com/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Learn to code&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt; (Codecademy，如果你英文 OK，&lt;b&gt;强烈建议&lt;/b&gt;你使用它进行交互式的学习！里面从 HTML/CSS 到搭建网站的课程都有，免费，生动直观）
        &lt;br /&gt;
    &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;b&gt;这个阶段的练习主要是“临摹”：用代码画出你想画的网站，越多越好。&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;对于书，我&lt;b&gt;非常不推荐&lt;/b&gt;上来就去看各种厚厚的入门/指南书，没必要！这一个阶段应该快速上手，培养兴趣，培养成就感。先做出可以看的东西再说，掌握常用的 HTML/CSS 就够用了
&lt;br /&gt;
&lt;br /&gt;如果完成的好，这个阶段过后你大概就可以写出一些简单又好看的“静态网页”了，比如这个作品集/简历：&lt;a href=&quot;//link.zhihu.com/?target=http%3A//huangxuan.me/portfolio/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Portfolio - 黄玄的博客&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt; （好久没更新了…丢人现眼）
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;b&gt;入门篇（JavaScript/jQuery）&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;想要在网页上实现一些交互效果，比如轮播图、点击按钮后播放动画？那你就必须要开始学习 JavaScript 了！JavaScript 是一门完整、强大并且非常热门的编程语言，你在浏览器里看到的所有交互或者高级功能都是由它在背后支撑的！
&lt;br /&gt;
&lt;br /&gt;举个小栗子：
&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Hello World!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;就这一行，就可以在浏览器里弹出 Hello World 啦！
&lt;br /&gt;
&lt;br /&gt;在了解一些基础的 JavaScript 概念（变量、函数、基本类型）后，我们可以直接去学习 jQuery，你不用知道它具体是什么（它是一个 JavaScript 代码库），你只要知道它可以显著地降低你编写交互的难度就好了：
&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'.className'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;click&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Hello jQuery&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过 jQuery，我们可以继续使用在 CSS 中学到的“选择器”
&lt;br /&gt;
&lt;br /&gt;对于没有编程基础的人来说，想要完全掌握它们两并不容易。作为设计师，很多时候我们可以先不必深究它们的原理，而是尝试直接应用它！这样成就感会来得很快，并且你可以通过实际应用更加理解 JavaScript 是用来做什么的。
&lt;br /&gt;
&lt;br /&gt;我仍然推荐你使用 &lt;a href=&quot;http://www.w3school.com.cn/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;w3school 在线教程&lt;/a&gt; 与 &lt;a href=&quot;//www.codecademy.com/&quot; target=&quot;_blank&quot;&gt;http://www.codecademy.com/&lt;/a&gt; 进行学习。另外，你可以看一看诸如《&lt;a href=&quot;//link.zhihu.com/?target=http%3A//book.douban.com/subject/10792216/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;锋利的jQuery (豆瓣)&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;》 这一类非常实用的书籍，可以让你很快上手做出一些简单的效果来！
&lt;br /&gt;
&lt;br /&gt;如果学习得顺利，你还可以尝试使用各种丰富的 jQuery 插件，你会发现写出支持用户交互的网站也没有那么困难～很多看上去很复杂的功能（比如轮播图、灯箱、下拉菜单），搜一搜然后看看文档（教程）、改改示例代码就好了。
&lt;br /&gt;
&lt;br /&gt;比如说，配合 &lt;a href=&quot;//link.zhihu.com/?target=https%3A//github.com/Huxpro/jquery.HSlider&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Huxpro/jquery.HSlider · GitHub&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt; 这样的轮播图插件，你可以很轻松的写出 &lt;a href=&quot;//link.zhihu.com/?target=http%3A//huangxuan.me/jquery.HSlider/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;HSlider | Demo&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt; 这样的网页相册或者 &lt;a href=&quot;//link.zhihu.com/?target=http%3A//huangxuan.me/jquery.HSlider/demo-weather-app/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;HSlider | Weather&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt; 这样的手机端 App 原型～
&lt;br /&gt;
&lt;br /&gt;最后，我想推荐下 &lt;a href=&quot;//link.zhihu.com/?target=http%3A//getbootstrap.com/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Bootstrap · The world’s most popular mobile-first and respons&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt; ，这是世界上最知名的前端 UI 框架之一，提供了大量 CSS 样式与 jQuery 插件。它非常容易学习并且中英文教程都非常健全，你并不需要理解它背后的工作原理就能很好的使用它，让你快速达到“可以建站的水平”。有余力的话，你不但可以学习如何使用它，还可以学习它背后的设计思想。
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;b&gt;转职方向一：前端重构 （Web Rebuild）&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;业内通常把专精 HTML/CSS 的前端从业人员称为重构，而对于注重视觉效果的设计师来说，在掌握基本的 HTML/CSS 后，就可以朝着这个方向发展了。
&lt;br /&gt;
&lt;br /&gt;&lt;b&gt;到了这个阶段，你不但要知道怎么写页面，还要知道它们都是为什么，并且知道怎么做更好。这对你理解 Web 世界非常有帮助，并且能帮助你做出更“系统化”的设计。&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;CSS 的学问很多，你需要开始理解文档流、浮动流等各种定位的方式与原理，理解 CSS 的继承复用思想、理解浏览器的差异、兼容、优雅降级……这里强烈推荐一本书：《&lt;a href=&quot;//link.zhihu.com/?target=http%3A//book.douban.com/subject/4736167/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;精通CSS（第2版） (豆瓣)&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;》，虽然前端技术突飞猛进，但这本书的思想永远不会过时。
&lt;br /&gt;
&lt;br /&gt;HTML 方面，要开始注重语义化、可访问性与结构的合理，你要开始学习“结构与样式的分离”，这里有一本神书将这种分离做到了极致：《&lt;a href=&quot;//link.zhihu.com/?target=http%3A//book.douban.com/subject/2052176/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;CSS禅意花园 (豆瓣)&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;》
&lt;br /&gt;
&lt;br /&gt;另外，各种炫酷屌的 CSS 3 属性你一定会喜欢：你可以用媒体查询做响应式网页设计，你可以用 transiton 和 animation 做补间动画与关键帧动画，用 transform 做缩放、旋转、3D变换，还有圆角、渐变、阴影、弹性盒！样样都是设计师的神器！
&lt;br /&gt;
&lt;br /&gt;如果你还掌握了 &lt;b&gt;入门篇（JavaScript/jQuery）&lt;/b&gt;的知识，那么&lt;b&gt;恭喜你！你已经可以做出很多有趣的网页了！&lt;/b&gt;很多 minisite 或者微信上的“H5” 小广告，这个程度的你已经可以轻松完成了！
&lt;br /&gt;
&lt;br /&gt;配合上你的设计功力，你可以开始尝试创作一些好玩的东西，比如这种富含交互和动画的网站 &lt;a href=&quot;//link.zhihu.com/?target=http%3A//huangxuan.me/senova/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;绅宝 SENOVA&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt; ，它仍然是基于 &lt;a href=&quot;//link.zhihu.com/?target=https%3A//github.com/Huxpro/jquery.HSlider&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Huxpro/jquery.HSlider · GitHub&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt; 实现的！或者给自己做个小小的个人网站试试
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;b&gt;转职方向二：前端工程师（Front-end Engineer）&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;如果你觉得上述的这些都还满足不了你，你渴望做出更多了不起的交互，甚至你已经喜欢上了编程，想要转行做工程师，或者成为一名全栈设计师，那么你可以朝着这个方向继续发展！
&lt;br /&gt;
&lt;br /&gt;这个阶段的最大难度，是你必须&lt;b&gt;学会像一名软件工程师一样思考&lt;/b&gt;。你需要踏踏实实学习编程语言，深入理解作用域、对象、类、封装、继承、面向对象编程、事件侦听、事件冒泡等一大堆编程概念，你还需要了解浏览器，学习 DOM、BOM、CSSOM 的 API，你甚至还需要学习一些网络原理，包括域名、URL、DNS、HTTP 请求都是什么…
&lt;br /&gt;
&lt;br /&gt;你可能会被这一大堆名词吓到。确实，想要搞定他们并不容易。但是，你要相信只要你肯花功夫它们也没有那么难，而更重要的是，如果你能拿下他们，你所收获的并不只是这些而已，而是真正跨过了一道大坎 —— &lt;b&gt;你的世界将因此打开， 你看待世界的方式将因此改变&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;对于这个阶段，你可以继续在 &lt;a href=&quot;//www.codecademy.com/&quot; target=&quot;_blank&quot;&gt;http://www.codecademy.com/&lt;/a&gt; 上学习，但是 w3school 已经不够用了，遇到不会的语法，我推荐你查阅 &lt;a href=&quot;//link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Mozilla 开发者网络&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;，这是少数中英文都有的非常专业且友好的网站。
&lt;br /&gt;
&lt;br /&gt;同时，你可能需要看一些书本来帮助你学习 JavaScript ：
&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt; 《&lt;a href=&quot;//link.zhihu.com/?target=http%3A//book.douban.com/subject/10546125/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;JavaScript高级程序设计（第3版） (豆瓣)&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt; 》或 《&lt;a href=&quot;//link.zhihu.com/?target=http%3A//book.douban.com/subject/2228378/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;JavaScript权威指南 (豆瓣)&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;》，大而全的书只需要一本就够了&lt;/li&gt;
    &lt;li&gt;如果上面这本你觉得太难，你可以先看 《&lt;a href=&quot;//link.zhihu.com/?target=http%3A//book.douban.com/subject/6038371/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;JavaScript DOM编程艺术 （第2版） (豆瓣)&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;》来过渡一下，这本书比较容易，它会教给你 “优雅降级、渐进增强”的优秀思想&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;如果你能顺利得渡过了这个阶段，我想你已经能做出很多令你自豪的网站了！试着向身边的工程师朋友询问如何购买域名、配置简单的静态服务器，或者搜搜“Github Pages”，然后把你的作品挂在网络上让大家欣赏吧！
&lt;br /&gt;
&lt;br /&gt;你还可以试着用 JavaScript 写写小游戏，这不但能锻炼你的编程水平还非常有趣～比如这是我刚学 JS 不久后 hack 一晚的产物 —— 用 DOM 实现的打飞机：&lt;a href=&quot;//link.zhihu.com/?target=http%3A//huangxuan.me/aircraft&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Hux - Aircraft&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt; （不支持手机）
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;b&gt;入行篇&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;如果你能完成上述所有的学习，你已经是一名非常出色的前端学徒了！对于只是想要丰富技能的设计师或者产品经理来说，接下来的内容可能会让你感到不适 ;(
&lt;br /&gt;但如果你铁了心想要真正入行进入大公司从事专职前端开发的工作，那么你可以接着往下看：
&lt;br /&gt;
&lt;br /&gt;近几年的前端技术发展迅猛，前端工程师早已不是切切图写写页面做点特效就完事的职位，你需要具备相当完善的工程师素质与计算机知识，成为一名真正的工程师。
&lt;br /&gt;
&lt;br /&gt;&lt;b&gt;你需要非常了解 JavaScript 这门语言&lt;/b&gt;，包括 闭包、IIFE、this、prototype 及一些底层实现（ES、VO、AO）、熟悉常用的设计模式与 JavaScript 范式（比如实现类与私有属性）。另外，新的 ES6 已经问世，包括 class, module, arrow function 等等
&lt;br /&gt;
&lt;br /&gt;&lt;b&gt;你需要非常了解前端常用的网络及后端知识&lt;/b&gt;，包括 Ajax、JSON、HTTP 请求、GET/POST 差异、RESTful、URL hash/query、webSocket、常用的跨域方式（JSONP/CORS、HTTP 强缓存/协商缓存，以及如何利用 CDN 、静态网站/动态网站区别、服务器端渲染/前端渲染区别等等
&lt;br /&gt;
&lt;br /&gt;&lt;b&gt;你需要学习使用进阶的 CSS&lt;/b&gt;，包括熟悉 CSS 3，使用 Scss/Less 等编译到 CSS 的语言，使用 autoprefixer 等 PostCSS 工具，了解 CSS 在 Scope/Namespace 上的缺陷，你还可以学习 CSS Modules、CSS in JS 这些有趣的新玩意
&lt;br /&gt;
&lt;br /&gt;&lt;b&gt;你需要非常了解前端的模块化规范&lt;/b&gt;，可能在你学习到这里的时候，Require.js/AMD 已经再见了，但是 CommonJS 与 ES6 Modules 你必须要了解。（你可以观看我的分享《&lt;a href=&quot;//link.zhihu.com/?target=http%3A//huangxuan.me/js-module-7day/%23/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;JavaScript Modularization Seven Day&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;》 来学习 JS 模块化的历史）
&lt;br /&gt;
&lt;br /&gt;&lt;b&gt;你需要熟悉 Git 与 Shell 的使用&lt;/b&gt;，包括基于 git 的版本管理、分支管理与团队协作，包括简单的 Linux/Unix 命令、你要知道大部分程序员的工作可以通过 shell 更快更酷的完成，并且很多“软件”只能通过 shell 来使用。你还可以把你的代码放到 github 上与人分享，并且学习 github 上其他优秀的开源代码
&lt;br /&gt;
&lt;br /&gt;&lt;b&gt;你需要熟悉并且习惯使用 Node&lt;/b&gt;，包括了解 npm、使用 Grunt/Gulp/Browserify/Webpack 优化你的工作流、对你的代码进行打包、混淆、压缩、发布，你还可以使用 Express/Koa 配合 MongoDB/Redis 涉足到后端领域，或者尝试用 Node 做后端渲染优化你的首屏体验
&lt;br /&gt;
&lt;br /&gt;&lt;b&gt;你需要了解各种 HTML 5 的新 API&lt;/b&gt;，包括 &amp;lt;video&amp;gt;/&amp;lt;audio&amp;gt;，包括 Canvas，webGL、File API、App Cache、localStorage、IndexedDB、Drag &amp;amp; Drop、更高级的 DOM API、Fetch API 等等
&lt;br /&gt;
&lt;br /&gt;&lt;b&gt;你需要学习 JavaScript 的单线程与异步编程方法&lt;/b&gt;，因为它们非常非常常用、包括 setTimeout/setInterval，回调与回调地狱、事件与event loop、还有 Promise 甚至 Async/Await
&lt;br /&gt;
&lt;br /&gt;&lt;b&gt;你需要非常了解浏览器&lt;/b&gt;，包括主流浏览器的名称、内核与差异、包括私有属性与 -webkit- 等厂商前缀，你需要学习如何使用 Chrome DevTool，你需要了解浏览器渲染的 reflow/repaint 来避免 Jank 并进行有针对性的性能优化
&lt;br /&gt;
&lt;br /&gt;&lt;b&gt;你需要专门学习 Mobile Web&lt;/b&gt;，因为移动互联网是趋势。包括 viewport、CSS pixel、 touch 事件、iOS/Android 浏览器的差异与兼容、移动端的性能优化、300ms delay 等等…你还需要知道 Hybrid 是什么，包括 Cordova/Phonegap，更复杂的比如和 iOS/Android 通信的机制，比如 URI Scheme 或者 JS Bridge
&lt;br /&gt;
&lt;br /&gt;&lt;b&gt;你需要学习一些&lt;/b&gt;&lt;b&gt;非常火热的前端框架/库&lt;/b&gt;，他们不但能帮助你更快的进行开发、更重要的是他们背后所蕴含的思想。包括 Backbone、Angular、Vue、React、Polymer 等等、了解它们背后的双向数据绑定、单向数据流、MVC/MVVM/Flux 思想、Web Component 与组件化等等
&lt;br /&gt;
&lt;br /&gt;&lt;b&gt;你需要学习如何构建 web 单页应用&lt;/b&gt;，这是 web 的未来，包括利用 history API 或者 hash 实现路由，包括基于 Ajax + 模版引擎或者其他技术的前端渲染、包括组织较为复杂的软件设计等等
&lt;br /&gt;
&lt;br /&gt;&lt;b&gt;我还建议你学习更多的计算机知识&lt;/b&gt;，它们能对你的代码能起到潜移默化的作用，包括简单的计算机体系结构、更广泛的编程知识（面向对象/函数式等）、栈、堆、数组、队列、哈希表、树、图等数据结构、时间复杂度与空间复杂度以及简单的算法等等
&lt;br /&gt;
&lt;br /&gt;&lt;b&gt;你需要了解业内的大神并阅读它们的博客/知乎/微博&lt;/b&gt;，比如 &lt;a data-hash=&quot;cfdec6226ece879d2571fbc274372e9f&quot; href=&quot;//www.zhihu.com/people/cfdec6226ece879d2571fbc274372e9f&quot; class=&quot;member_mention&quot; data-editable=&quot;true&quot; data-title=&quot;@尤雨溪&quot; data-tip=&quot;p$b$cfdec6226ece879d2571fbc274372e9f&quot;&gt;@尤雨溪&lt;/a&gt;&lt;a data-hash=&quot;3ec3b166992a5a90a1083945d2490d38&quot; href=&quot;//www.zhihu.com/people/3ec3b166992a5a90a1083945d2490d38&quot; class=&quot;member_mention&quot; data-editable=&quot;true&quot; data-title=&quot;@贺师俊&quot; data-tip=&quot;p$b$3ec3b166992a5a90a1083945d2490d38&quot;&gt;@贺师俊&lt;/a&gt;&lt;a data-hash=&quot;3212f9044005e9306aab1b61e74e7ae6&quot; href=&quot;//www.zhihu.com/people/3212f9044005e9306aab1b61e74e7ae6&quot; class=&quot;member_mention&quot; data-editable=&quot;true&quot; data-title=&quot;@张云龙&quot; data-tip=&quot;p$b$3212f9044005e9306aab1b61e74e7ae6&quot;&gt;@张云龙&lt;/a&gt;&lt;a data-hash=&quot;c5198d4e9c0145aee04dd53cc6590edd&quot; href=&quot;//www.zhihu.com/people/c5198d4e9c0145aee04dd53cc6590edd&quot; class=&quot;member_mention&quot; data-editable=&quot;true&quot; data-title=&quot;@徐飞&quot; data-tip=&quot;p$b$c5198d4e9c0145aee04dd53cc6590edd&quot;&gt;@徐飞&lt;/a&gt;&lt;a data-hash=&quot;20fdd386a6e59d178b8fe14e2863cb40&quot; href=&quot;//www.zhihu.com/people/20fdd386a6e59d178b8fe14e2863cb40&quot; class=&quot;member_mention&quot; data-editable=&quot;true&quot; data-title=&quot;@张克军&quot; data-tip=&quot;p$b$20fdd386a6e59d178b8fe14e2863cb40&quot;&gt;@张克军&lt;/a&gt;&lt;a data-hash=&quot;c11336b8607d86bc9090bed90757a34c&quot; href=&quot;//www.zhihu.com/people/c11336b8607d86bc9090bed90757a34c&quot; class=&quot;member_mention&quot; data-editable=&quot;true&quot; data-title=&quot;@玉伯&quot; data-tip=&quot;p$b$c11336b8607d86bc9090bed90757a34c&quot;&gt;@玉伯&lt;/a&gt;&lt;a data-hash=&quot;64458d15a75902cd0425732b7b757705&quot; href=&quot;//www.zhihu.com/people/64458d15a75902cd0425732b7b757705&quot; class=&quot;member_mention&quot; data-editable=&quot;true&quot; data-title=&quot;@拔赤&quot; data-tip=&quot;p$b$64458d15a75902cd0425732b7b757705&quot;&gt;@拔赤&lt;/a&gt;&lt;a data-hash=&quot;0d9b98af12015c94cff646a6fc0773b5&quot; href=&quot;//www.zhihu.com/people/0d9b98af12015c94cff646a6fc0773b5&quot; class=&quot;member_mention&quot; data-editable=&quot;true&quot; data-title=&quot;@寸志&quot; data-tip=&quot;p$b$0d9b98af12015c94cff646a6fc0773b5&quot;&gt;@寸志&lt;/a&gt;&lt;a data-hash=&quot;790dccce26904cdcd11b0fad3bac37b7&quot; href=&quot;//www.zhihu.com/people/790dccce26904cdcd11b0fad3bac37b7&quot; class=&quot;member_mention&quot; data-editable=&quot;true&quot; data-title=&quot;@题叶&quot; data-tip=&quot;p$b$790dccce26904cdcd11b0fad3bac37b7&quot;&gt;@题叶&lt;/a&gt;&lt;a data-hash=&quot;85de6407f2219137df29b4249b91cfd5&quot; href=&quot;//www.zhihu.com/people/85de6407f2219137df29b4249b91cfd5&quot; class=&quot;member_mention&quot; data-editable=&quot;true&quot; data-title=&quot;@郭达峰&quot; data-tip=&quot;p$b$85de6407f2219137df29b4249b91cfd5&quot;&gt;@郭达峰&lt;/a&gt; 等等等等，很多思想和新东西只有从他们身上才能学到。我还推荐你多参加技术交流会，多认识一些可以一起学习的小伙伴，你们可以互相交流并且一起成长
&lt;br /&gt;
&lt;br /&gt;&lt;b&gt;你需要具备很强的自学能力、对技术有热情并且不断跟进&lt;/b&gt;。因为 JavaScript/前端的社区非常非常活跃，有太多的新东西需要你自己来发现与学习：比如 Universal JavaScript、Isomorphic JavaScript、前端测试、HTML5 页游、WebRTC、WebSocket、CSS 4、SVG、HTTP/2、ES 7、React Native、Babel、TypeScript、Electron 等等等等…
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;虽然一下扯得有点多，但这些确实就是你未来将会遇到的。你并不需要全部掌握它们，但是却多多益善；你也可以专精在某几个方面，这已经足以让你成为非常专业的前端工程师。
&lt;br /&gt;
&lt;br /&gt;&lt;b&gt;所以，如果你自认为涵盖了上述要求的 40%，欢迎简历发 huangxuan@wepiao.com ，实习/全职皆可～&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;咦，这个结尾怪怪的……&lt;/p&gt;

</description>
        <pubDate>Wed, 28 Oct 2015 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2015/10/28/how-designer-learn-fe/</link>
        <guid isPermaLink="true">http://localhost:4000/2015/10/28/how-designer-learn-fe/</guid>
        
        <category>知乎</category>
        
        <category>前端开发</category>
        
        <category>UX Design</category>
        
        
      </item>
    
      <item>
        <title>ES5, ES6, ES2016, ES.Next: JavaScript 的版本是怎么回事？「译」</title>
        <description>&lt;p&gt;JavaScript 有着很奇怪的命名史。&lt;/p&gt;

&lt;p&gt;1995 年，它作为网景浏览器（Netscape Navigator）的一部分首次发布，网景给这个新语言命名为 LiveScript。一年后，为了搭上当时媒体热炒 Java 的顺风车，临时改名为了 JavaScript &lt;em&gt;（当然，Java 和 JavaScript 的关系，就和雷锋和雷锋塔一样 —— 并没有什么关系）&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-js-version/javascript-java.jpg&quot; alt=&quot;java-javascript&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;歪果仁的笑话怎么一点都不好笑&lt;/small&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;译者注：&lt;a href=&quot;https://en.wikipedia.org/wiki/JavaScript#History&quot;&gt;wikipedia 的 JavaScript 词条&lt;/a&gt; 更详细的叙述了这段历史&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;1996 年，网景将 JavaScript 提交给 &lt;a href=&quot;http://www.ecma-international.org/&quot;&gt;ECMA International（欧洲计算机制造商协会）&lt;/a&gt; 进行标准化，并最终确定出新的语言标准，它就是 ECMAScript。自此，ECMAScript 成为所有 JavaScript 实现的基础，不过，由于 JavaScript 名字的历史原因和市场原因（很显然 ECMAScript 这个名字并不令人喜欢……），现实中我们只用 ECMAScript 称呼标准，平时都还是使用 JavaScript 来称呼这个语言。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;术语（译者注）：&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;em&gt;标准（Standard）&lt;/em&gt;： 用于定义与其他事物区别的一套规则&lt;/li&gt;
    &lt;li&gt;&lt;em&gt;实现（Implementation）&lt;/em&gt;： 某个标准的具体实施/真实实践&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;不过，JavaScript 开发者们并不怎么在乎这些，因为在诞生之后的 15 年里，ECMAScript 并没有多少变化，而且现实中的很多实现都已经和标准大相径庭。其实在第一版的 ECMAScript 发布后，很快又跟进发布了两个版本，但是自从 1999 年 ECMAScript 3 发布后，十年内都没有任何改动被成功添加到官方规范里。取而代之的，是各大浏览器厂商们争先进行自己的语言拓展，web 开发者们别无选择只能去尝试并且支持这些 API。即使是在 2009 年 ECMAScript 5 发布之后，仍然用了数年这些新规范才得到了浏览器的广泛支持，可是大部分开发者还是写着 ECMAScript 3 风格的代码，并不觉得有必要去了解这些规范。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;译者注：&lt;a href=&quot;https://en.wikipedia.org/wiki/ECMAScript#4th_Edition_.28abandoned.29&quot;&gt;ECMAScript 第四版草案&lt;/a&gt;由于太过激进而被抛弃，Adobe 的 &lt;a href=&quot;https://en.wikipedia.org/wiki/ActionScript&quot;&gt;ActionScript 3.0&lt;/a&gt; 是 ECMAScript edition 4 的唯一实现（ Flash 差点就统一 Web 了）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;到了 2012 年，事情突然开始有了转变。大家开始推动停止对旧版本 IE 浏览器的支持，用 ECMAScript 5 (ES5) 风格来编写代码也变得更加可行。与此同时，一个新的 ECMAScript 规范也开始启动。到了这时，大家开始逐渐习惯以对 ECMAScript 规范的版本支持程度来形容各种 JavaScript 实现。在正式被指名为 ECMAScript 第 6 版 (ES6) 之前，这个新的标准原本被称为 ES.Harmony（和谐）。2015 年，负责制定 ECMAScript 规范草案的委员会 TC39 决定将定义新标准的制度改为一年一次，这意味着每个新特性一旦被批准就可以添加，而不像以往一样，规范只有在整个草案完成，所有特性都没问题后才能被定稿。因此，ECMAScript 第 6 版在六月份公布之前，又被重命名为了 ECMAScript 2015（ES2015）&lt;/p&gt;

&lt;p&gt;目前，仍然有很多新的 JavaScript 特性或语法正在提议中，包括 &lt;a href=&quot;https://github.com/wycats/javascript-decorators&quot;&gt;decorators（装饰者）&lt;/a&gt;，&lt;a href=&quot;https://github.com/lukehoban/ecmascript-asyncawait&quot;&gt;async-await（async-await 异步编程模型）&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/jeffmo/es-class-properties&quot;&gt;static class properties（静态类属性）&lt;/a&gt;。它们通常被称为 ES7，ES2016 或者 ES.Next 的特性，不过实际上它们只能被称作提案或者说可能性，毕竟 ES2016 的规范还没有完成，有可能全部都会引入，也有可能一个都没有。TC39 把一个提案分为 4 个阶段，你可以在 &lt;a href=&quot;https://babeljs.io/docs/usage/experimental/&quot;&gt;Babel 的官网&lt;/a&gt; 上查看各个提案目前都在哪个阶段了。&lt;/p&gt;

&lt;p&gt;所以，我们该如何使用这一大堆术语呢？下面的列表或许能帮助到你：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;ECMAScript&lt;/strong&gt;：一个由 ECMA International 进行标准化，TC39 委员会进行监督的语言。通常用于指代标准本身。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;JavaScript&lt;/strong&gt;：ECMAScript 标准的各种实现的最常用称呼。这个术语并不局限于某个特定版本的 ECMAScript 规范，并且可能被用于任何不同程度的任意版本的 ECMAScript 的实现。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ECMAScript 5 (ES5)&lt;/strong&gt;：ECMAScript 的第五版修订，于 2009 年完成标准化。这个规范在所有现代浏览器中都相当完全的实现了。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ECMAScript 6 (ES6) / ECMAScript 2015 (ES2015)&lt;/strong&gt;：ECMAScript 的第六版修订，于 2015 年完成标准化。这个标准被部分实现于大部分现代浏览器。可以查阅&lt;a href=&quot;http://kangax.github.io/compat-table/es6/&quot;&gt;这张兼容性表&lt;/a&gt;来查看不同浏览器和工具的实现情况。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ECMAScript 2016&lt;/strong&gt;：预计的第七版 ECMAScript 修订，计划于明年夏季发布。这份规范具体将包含哪些特性还没有最终确定&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ECMAScript Proposals&lt;/strong&gt;：被考虑加入未来版本 ECMAScript 标准的特性与语法提案，他们需要经历五个阶段：Strawman（稻草人），Proposal（提议），Draft（草案），Candidate（候选）以及 Finished （完成）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在这整个 Blog 中，我将把目前的 ECMAScript 版本称作 ES6（因为这是大部分开发者最习以为常的），把明年的规范称作 ES2016（因为，与 ES6/ES2015 不同，这个名字将在整个标准化过程中沿用）并且将那些还没有成为 ECMAScript 定稿或草案的未来语言概念称为 ECMAScript 提案或者 JavaScript 提案。我将尽我所能在任何可能引起困惑的场合沿用这篇文章。&lt;/p&gt;

&lt;h4 id=&quot;一些资源&quot;&gt;一些资源&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;TC39 的 &lt;a href=&quot;https://github.com/tc39/ecma262&quot;&gt;Github 仓库&lt;/a&gt;上可以看到所有目前公开的提案&lt;/li&gt;
  &lt;li&gt;如果你还不熟悉 ES6，Babel 有一个&lt;a href=&quot;https://babeljs.io/docs/learn-es2015/&quot;&gt;很不错的特性概览&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;如果你希望深入 ES6，这里有两本很不错的书： Axel Rauschmayer 的 &lt;a href=&quot;http://exploringjs.com/&quot;&gt;Exploring ES6&lt;/a&gt;和 Nicholas Zakas 的 &lt;a href=&quot;https://leanpub.com/understandinges6&quot;&gt;Understanding ECMAScript 6&lt;/a&gt;。Axel 的博客 &lt;a href=&quot;http://www.2ality.com/&quot;&gt;2ality&lt;/a&gt; 也是很不错的 ES6 资源&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img class=&quot;shadow&quot; width=&quot;320&quot; src=&quot;/img/in-post/post-js-version/keep-calm-and-learn-javascript.png&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;来学 JavaScript 吧！&lt;/small&gt;&lt;/p&gt;

&lt;h4 id=&quot;著作权声明&quot;&gt;著作权声明&lt;/h4&gt;

&lt;p&gt;本文译自 &lt;a href=&quot;http://benmccormick.org/2015/09/14/es5-es6-es2016-es-next-whats-going-on-with-javascript-versioning/&quot;&gt;ES5, ES6, ES2016, ES.Next: What’s going on with JavaScript versioning?&lt;/a&gt; &lt;br /&gt;
译者 &lt;a href=&quot;http://weibo.com/huxpro&quot;&gt;黄玄&lt;/a&gt;，首次发布于 &lt;a href=&quot;http://huangxuan.me&quot;&gt;Hux Blog&lt;/a&gt;，转载请保留以上链接&lt;/p&gt;

</description>
        <pubDate>Tue, 22 Sep 2015 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2015/09/22/js-version/</link>
        <guid isPermaLink="true">http://localhost:4000/2015/09/22/js-version/</guid>
        
        <category>前端开发</category>
        
        <category>JavaScript</category>
        
        <category>翻译</category>
        
        
      </item>
    
      <item>
        <title>JavaScript 模块化七日谈</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;下滑这里查看更多内容&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;7月9日，我在公司内部进行了名为「JavaScript 模块化七日谈」分享，并将该 Slides 分享到了微博上。出乎意料地，这篇微博先后被 @JS小组 @尤小右 @寸志 等近 200 人转发，阅读达到 10w，获得了还不错的评价。&lt;/p&gt;

&lt;p&gt;于是，我决定将它重新发到我的博客上，并为它专门制作了适用于 Keynote 展示文稿的新布局。它能自动根据屏幕大小/旋转以一定比例填充屏幕，你也可以直接点击下方链接在新页面打开，来获得更好的、沉浸式的全屏体验&lt;/p&gt;

&lt;h3 id=&quot;watch-fullscreen-&quot;&gt;&lt;a href=&quot;https://huangxuan.me/js-module-7day/&quot;&gt;Watch Fullscreen →&lt;/a&gt;&lt;/h3&gt;

&lt;div class=&quot;visible-md visible-lg&quot;&gt;
&lt;img src=&quot;//huangxuan.me/js-module-7day/attach/qrcode.png&quot; width=&quot;350&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;你也可以通过扫描二维码在手机上观看&lt;/small&gt;
&lt;/div&gt;

&lt;p&gt;这个 Web Slides 开源在&lt;a href=&quot;https://github.com/Huxpro/js-module-7day&quot;&gt;我的 Github 上&lt;/a&gt;，欢迎你帮助我完善这个展示文稿，你可以给我提 issue，可以 fork &amp;amp; pull request。如果它能帮助到你了，希望你还能不吝啬 star 一下这个项目&lt;/p&gt;

&lt;h3 id=&quot;catalog&quot;&gt;Catalog&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;第一日 上古时期 &lt;strong&gt;&lt;em&gt;Module?&lt;/em&gt;&lt;/strong&gt; 从设计模式说起&lt;/li&gt;
  &lt;li&gt;第二日 石器时代 &lt;strong&gt;&lt;em&gt;Script Loader&lt;/em&gt;&lt;/strong&gt; 只有封装性可不够，我们还需要加载&lt;/li&gt;
  &lt;li&gt;第三日 蒸汽朋克 &lt;strong&gt;&lt;em&gt;Module Loader&lt;/em&gt;&lt;/strong&gt; 模块化架构的工业革命&lt;/li&gt;
  &lt;li&gt;第四日 号角吹响 &lt;strong&gt;&lt;em&gt;CommonJS&lt;/em&gt;&lt;/strong&gt; 征服世界的第一步是跳出浏览器&lt;/li&gt;
  &lt;li&gt;第五日 双塔奇兵 &lt;strong&gt;&lt;em&gt;AMD/CMD&lt;/em&gt;&lt;/strong&gt; 浏览器环境模块化方案&lt;/li&gt;
  &lt;li&gt;第六日 精灵宝钻 &lt;strong&gt;&lt;em&gt;Browserify/Webpack&lt;/em&gt;&lt;/strong&gt; 大势所趋，去掉这层包裹！&lt;/li&gt;
  &lt;li&gt;第七日 王者归来 &lt;strong&gt;&lt;em&gt;ES6 Module&lt;/em&gt;&lt;/strong&gt; 最后的战役&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;thanks&quot;&gt;Thanks&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://lab.hakim.se/reveal-js&quot;&gt;Reveal.js&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 09 Jul 2015 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2015/07/09/js-module-7day/</link>
        <guid isPermaLink="true">http://localhost:4000/2015/07/09/js-module-7day/</guid>
        
        <category>前端开发</category>
        
        <category>JavaScript</category>
        
        
      </item>
    
  </channel>
</rss>
